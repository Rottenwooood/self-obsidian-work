### STC89C52规格

我的是STC89C52RC

位数为8位，RAM为512字节，ROM为8K，工作频率为12MHz。

> STC：公司名称
> 89：类型为STC 12T/6T 8051
> C：工作电压为5.5V-3.8V
> 5：固定不变
> 1：程序空间为8K字节
> RC：RAM空间为512字节
> 40：表示芯片外部晶振最高可接入40MHz
> I：工作温度范围为工业级 -40℃-80℃
> PDIP：封装类型为PDIP
> 40：管脚数为40

#### 内部结构：

#### 

<img src="https://i-blog.csdnimg.cn/direct/f8a92f9e47a94f36a660a8847277d8e3.png" alt="在这里插入图片描述" style="zoom:50%;" />

#### 

#### 1管脚

#### 

<img src="https://i-blog.csdnimg.cn/direct/5355443efc7746e392d1310e28a0d1af.png" alt="在这里插入图片描述" style="zoom: 67%;" />

> 

一些重要的管脚：
 Vcc：电源正极
 Gnd：电源负极
 XTAL1/XTAL2：外接晶振

### 开发版原理图

 [普中-2&普中-3&普中-4开发板原理图.pdf](D:\Admin\Downloads\普中-2&普中-3&普中-4开发板原理图.pdf) 

### 项目设置

- AT89C52
- Options for Target-Output-Create HEX File
- 添加新文件名称为main.c
-  # include <REGX52.H>
- 编译-Build-F7
- ![image-20241024233847333](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241024233847333.png)

- 标准main函数

  ```c
  void main()
  {
  	while(1)
  	{
  
  	}
  }
  ```

  

### 位寻址

在8051单片机的C语言编程中，`P3^6`是一种位寻址的表示方法，用于访问单片机的端口3（P3）的第6位。这里的`^`符号是位寻址操作符，用来指定端口中的特定位。

具体来说，`P3^6`表示的是：

- `P3`：指的是8051单片机的第三个I/O端口，也就是P3端口。
- `^6`：表示P3端口的第6位，也就是P3.6。

在8051单片机中，每个端口（如P0、P1、P2、P3等）都有8位，分别标记为P0.0、P0.1、...、P0.7，P1.0、P1.1、...、P1.7，以此类推。这些位可以被单独访问和控制，这在进行位操作时非常有用，比如控制单个LED灯、读取按钮状态等。

### LED

LED模块原理图：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241024232659978.png" alt="image-20241024232659978" style="zoom: 50%;" />

> D1-D9:P2_0-P2_7，P2的范围为0-255，
>
> 寄存器以八个为一组，所以P20-P27可以直接以P2的形式呈现。
>
> 端口输出低电平(0)为导通状态，LED分压，亮；端口输出高电平(1)为断开状态，LED两端电压相等，灭

如设置`P2 = 1111 1110;`则P27口输出0，D8点亮。

实际操作中需要转化为十六进制`P2 = 0xFE;`

也可单独设置各个端口如`P2_0=0;` 

### 延时代码

用stc-isp里的软件延时计算器生成实现延时功能的自定义函数。

STC89C52RC系统频率11.0592Ghz

STC89C52系统频率12Ghz

生成一个以1ms为单位间隔的自定义函数，给定一个参数表示自定义的间隔时间，修改延时函数：

```c
#include <intrins.h>//提供_nop_()函数

void Delay(unsigned int xms)			//@11.0592MHz
{
	unsigned char i, j;
	_nop_();
	while(xms)
	{
		i = 2;
		j = 199;
		do
		{
			while (--j);
		} while (--i);
		xms--;
	}
}
```

### 独立按键

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241024234537870.png" alt="image-20241024234537870" style="zoom:50%;" />

这里P31和P30仍然是接反了的。

按键按下时，GND和寄存器导通，寄存器电位被拉低为低电平0。

机械开关断开和闭合时，由于机械触电的弹性作用，不会立刻进入稳定状态，而是会伴随一系列的抖动状态

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241024235031778.png" alt="image-20241024235031778" style="zoom:50%;" />

消抖代码：

```c
if(P3_0==0) 
{
	Delay(20);
	while(P3_0==0);//直到按键松开才执行完跳出死循环 
	Delay(20);
	LEDNum++;//定义：unsigned char LEDNum=0;
	P2=~LEDNum;  
}
```

实现移位可以用位运算符中的<<和>>：

`LEDNum<<=1;`

`P2 =~ (0x01<<LEDNum);//当LED位置与二进制方位相反时|0000 0001->1000 0000,LEDNum初始值为7，此后每次循环减1`

按键实现LED移位：

```c
void main()
{
	unsigned char LEDNum=0;
	P2=~0x01;
	while(1)
	{
		if(P3_1==0)
		{
			Delay(20);
			while(P3_1==0);
			Delay(20);
			if(LEDNum==0) LEDNum=7;
			else LEDNum--;
			P2 =~ (0x01<<LEDNum);
		}
		if(P3_0==0)
		{
			Delay(20);
			while(P3_0==0);
			Delay(20);
			LEDNum++;
			if(LEDNum>=8) LEDNum=0;
			P2 =~ (0x01<<LEDNum);
		}
	}
}
```

### 数码管

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241025134749388.png" alt="image-20241025134749388" style="zoom:50%;" />

> **COM**：共阴极，要选中哪个数码管，就给这个COM端输入低电平（0）。
>  **a、b、c、d、e、f、g、dp**：共阳极，输入高电平（1）有效。
>  左边的芯片是双向数据缓冲器。
>
> P0_0-P0_7分别负责dp-a的位选
>
> a、b、c、d、e、f、g、dp以二进制表示时顺序为dp、g、f、e、d、c、b、a。例如要选中b和c，那么二进制表示则为0000 0110，转换为二进制则为0x06。

数码管驱动方式:

- **单片机直接扫描**：硬件设备简单，但是会耗费大量的单片机时间。
-  **专用驱动芯片扫描**：内部自带显存、扫描电路，单片机只需要告诉它显示什么即可。带有此功能的芯片例如TM1640。

#### 138译码器：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241025134935845.png" alt="image-20241025134935845" style="zoom: 67%;" />

138译码器是三线—八线译码器，由ABC输入量决定了Y端的有效性。使用时，将输入量以CBA的顺序排列，分别对应的是二进制的第三位、第二位、第一位，将输入量对应的数转换为十进制后，即可得出有效的Y口。
例如，当C(P2_4)、B(P2_3)、A(P2_2)输入分别为0、0、1时，对应的二进制为001，转化为十进制为1，即有效的Y口为Y1。
需要注意的是，Y口的有效情况为低电平(0)有效，即有效时输出为0。
因此每个Y端之前都取非了一次（上方横线）

#### 数码管的静态显示

```c
#include <at89c51RC2.h>
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00};//对应0-9
void Nixie(unsigned char LED,Number)
{
	switch(LED)
	{  
		case 1: P2_4=0;P2_3=0;P2_2=0;break;
		case 2: P2_4=0;P2_3=0;P2_2=1;break;
		case 3: P2_4=0;P2_3=1;P2_2=0;break;
		case 4: P2_4=0;P2_3=1;P2_2=1;break;
		case 5: P2_4=1;P2_3=0;P2_2=0;break;
		case 6: P2_4=1;P2_3=0;P2_2=1;break;
		case 7: P2_4=1;P2_3=1;P2_2=0;break;
		case 8: P2_4=1;P2_3=1;P2_2=1;break;
	}
	P0=NixieTable[Number];
}	
void main()
{
	while(1)
	{
		Nixie(1,5);
	}
}
```

#### 动态显示

如果直接在循环中多次执行函数：

```c
while(1)
{
	Nixie(8,1);
	Nixie(7,2);
	Nixie(6,3);
}
```

则会发生错误

数码管在显示时一直在进行 位选(选择让哪个数码管亮) 段选(选择让这个数码管显示显示什么数字) **位选 段选** 位选 段选… 的过程。还是因为执行速度太快，段选过后单片机上面的针脚有几毫秒还处于该段选的显示状态，然后在这几毫秒内单片机又进行了下一位位选，所以导致了在选择了下一位位选时还保留了上一条段选的显示状态，所以会出现错位的情况。
为解决这个问题，我们要**进行消影处理**，即**在段选和位选之间进行清零**。
段选的结尾在Nixie()函数，所以应在Nixie()函数中进行处理。**清零即对于针脚全都不选择，用 `P0=0x00`** 。

按照上述操作，数码管的显示会比较暗。
 为解决此问题，可以**在清零前加1ms的延迟。**

`Delay(1);`

```c
void Nixie(unsigned char LED,Number)
{
	switch(LED)
	{  
		case 1: P2_4=0;P2_3=0;P2_2=0;break;
		case 2: P2_4=0;P2_3=0;P2_2=1;break;
		case 3: P2_4=0;P2_3=1;P2_2=0;break;
		case 4: P2_4=0;P2_3=1;P2_2=1;break;
		case 5: P2_4=1;P2_3=0;P2_2=0;break;
		case 6: P2_4=1;P2_3=0;P2_2=1;break;
		case 7: P2_4=1;P2_3=1;P2_2=0;break;
		case 8: P2_4=1;P2_3=1;P2_2=1;break;
	}
	P0=NixieTable[Number];
	Delay(1);
	P0=0x00;
}	
```

### 模块化编程

文件目录

![image-20241025141736756](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241025141736756.png)

.H文件中格式

```c
#ifndef __DELAY_H__//宏定义守卫|如果没有define __DELAY_H__，即如果没有include delay.文件->
#define __DELAY_H__//则define __DELAY_H__宏，它没有被定义为任何特定的值或代码，它仅仅作为一个标记存在

void Delay(unsigned int xms);

#endif//宏定义守卫的结束部分
```

.c文件中定义函数，变量（如果需要在main.c中使用则加上extern关键字），如果需要使用其他模块的内容，则需要include其他模块，无须担心重复编译

在main.c中`#include delay.h`

### LCD1602 LCD1602.h

一种字符型液晶显示模块，可以显示ASCII的标准字符和其他的一些内置特殊字符，还可以有8个自定义字符。
 显示容量为**16 * 2个字符，每个字符为5 * 7点阵**。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241025143311417.png" alt="image-20241025143311417" style="zoom:67%;" />

>  **GND**：接地。
>  **VCC**：电源正极（4.5V~5.5V）。
>
>  **VO**：对比度调节电压。
>  **RS**：**数据/指令选择**，1为数据，0为指令。对应**P2_6**
>  **RW**：**读/写选择**，1为读，0为写。对应**P2_5**
>  **E**：**使能**，1为数据有效，下降沿执行指令。对应**P2_7**
>  **D0~D7**：并行**传输数据**。对应**P0_0-P0_7**
>  **BG VCC**：背光灯电源正极。
>  **BG GND**：背光灯电源负极。
>
>  **RJ1:**用以调整对比度

> 16列x2行，显示器显示2行，每行16个字符。
> 专门用来显示字母、数字、符号的点阵型液晶模块
> 能显示32个字符.
> LCD1602内置了字库。可以直接获取字模！不能显示中文
>
> LCD1602带ASCII码字库，当我们想让LCD1602显示某个ASCII码字符时，只需要将这个字符对应的ASCII码发给LCD1602内部的控制器，控制器就会去查字库得到字模，然后将字模发给内部的驱动器去驱动LCD做显示。

> RS=H时，D0-D7上传输的是**数据**
> RS=L时，D0-D7上传输的是**命令**
> RW=H时，表示我们要读
> RW=L时，表示我们要写
> E=H时，表示使能      
> E=L时，表示禁止（禁能）

已解读完毕！

```c
#include <REGX52.H>

//引脚配置：
sbit LCD_RS=P2^6;
sbit LCD_RW=P2^5;
sbit LCD_EN=P2^7;
#define LCD_DataPort P0

//函数定义：
/**
  * @brief  LCD1602延时函数，12MHz调用可延时1ms
  * @param  无
  * @retval 无
  */
void LCD_Delay()
{
	unsigned char i, j;

	i = 2;
	j = 239;
	do
	{
		while (--j);
	} while (--i);
}

/**
  * @brief  LCD1602写命令
  * @param  Command 要写入的命令
  * @retval 无
  */
void LCD_WriteCommand(unsigned char Command)
{
	LCD_RS=0;//指令
	LCD_RW=0;//写
	LCD_DataPort=Command;//P0
	LCD_EN=1;//使能
	LCD_Delay();
	LCD_EN=0;//使不能
	LCD_Delay();
}

/**
  * @brief  LCD1602写数据
  * @param  Data 要写入的数据
  * @retval 无
  */
void LCD_WriteData(unsigned char Data)
{
	LCD_RS=1;//数据
	LCD_RW=0;//写
	LCD_DataPort=Data;//P0
	LCD_EN=1;
	LCD_Delay();
	LCD_EN=0;
	LCD_Delay();
}

/**
  * @brief  LCD1602设置光标位置
  * @param  Line 行位置，范围：1~2
  * @param  Column 列位置，范围：1~16
  * @retval 无
  */
void LCD_SetCursor(unsigned char Line,unsigned char Column)
{
	if(Line==1)
	{
		LCD_WriteCommand(0x80|(Column-1));//1000 +四位地址码0x00-0x27
	}
	else if(Line==2)
	{
		LCD_WriteCommand(0x80|(Column-1+0x40));//1000 +四位地址码0x40-0x67
	}
}

/**
  * @brief  LCD1602初始化函数
  * @param  无
  * @retval 无
  */
void LCD_Init()
{
	LCD_WriteCommand(0x38);//八位数据接口，两行显示，5*7点阵 0011 1000
	LCD_WriteCommand(0x0c);//显示开，光标关，闪烁关 0000 1100
	LCD_WriteCommand(0x06);//数据读写操作后，光标自动加一，画面不动 0000 0110
	LCD_WriteCommand(0x01);//光标复位，清屏 0000 0001
}

/**
  * @brief  在LCD1602指定位置上显示一个字符
  * @param  Line 行位置，范围：1~2
  * @param  Column 列位置，范围：1~16
  * @param  Char 要显示的字符
  * @retval 无
  */
void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char)
{
	LCD_SetCursor(Line,Column);//设置光标位置
	LCD_WriteData(Char);//写数据
}

/**
  * @brief  在LCD1602指定位置开始显示所给字符串
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  String 要显示的字符串
  * @retval 无
  */
void LCD_ShowString(unsigned char Line,unsigned char Column,char *String)
{
	unsigned char i;
	LCD_SetCursor(Line,Column);//读写操作后光标自动加一，故无须更改
	for(i=0;String[i]!='\0';i++)
	{
		LCD_WriteData(String[i]);
	}
}

/**
  * @brief  返回值=X的Y次方
  */
int LCD_Pow(int X,int Y)
{
	unsigned char i;
	int Result=1;
	for(i=0;i<Y;i++)
	{
		Result*=X;
	}
	return Result;
}

/**
  * @brief  在LCD1602指定位置开始显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~65535
  * @param  Length 要显示数字的长度，范围：1~5
  * @retval 无
  */
void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
	unsigned char i;
	LCD_SetCursor(Line,Column);
	for(i=Length;i>0;i--)
	{
		LCD_WriteData(Number/LCD_Pow(10,i-1)%10+'0');//如输入65535，则依次输出6，5，5，3，5
	}//+"0"目的：从"0"对应数字开始
}

/**
  * @brief  在LCD1602指定位置开始以有符号十进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：-32768~32767
  * @param  Length 要显示数字的长度，范围：1~5
  * @retval 无
  */
void LCD_ShowSignedNum(unsigned char Line,unsigned char Column,int Number,unsigned char Length)
{
	unsigned char i;
	unsigned int Number1;
	LCD_SetCursor(Line,Column);
	if(Number>=0)
	{
		LCD_WriteData('+');
		Number1=Number;
	}
	else
	{
		LCD_WriteData('-');
		Number1=-Number;
	}
	for(i=Length;i>0;i--)
	{
		LCD_WriteData(Number1/LCD_Pow(10,i-1)%10+'0');
	}
}

/**
  * @brief  在LCD1602指定位置开始以十六进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~0xFFFF
  * @param  Length 要显示数字的长度，范围：1~4
  * @retval 无
  */
void LCD_ShowHexNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
	unsigned char i,SingleNumber;
	LCD_SetCursor(Line,Column);
	for(i=Length;i>0;i--)
	{
		SingleNumber=Number/LCD_Pow(16,i-1)%16;
		if(SingleNumber<10)
		{
			LCD_WriteData(SingleNumber+'0');
		}
		else
		{
			LCD_WriteData(SingleNumber-10+'A');
		}
	}
}

/**
  * @brief  在LCD1602指定位置开始以二进制显示所给数字
  * @param  Line 起始行位置，范围：1~2
  * @param  Column 起始列位置，范围：1~16
  * @param  Number 要显示的数字，范围：0~1111 1111 1111 1111
  * @param  Length 要显示数字的长度，范围：1~16
  * @retval 无
  */
void LCD_ShowBinNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)
{
	unsigned char i;
	LCD_SetCursor(Line,Column);
	for(i=Length;i>0;i--)
	{
		LCD_WriteData(Number/LCD_Pow(2,i-1)%2+'0');
	}
}

```



### 矩阵键盘 MatrixKey.c和MatrixKey.h

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241025153311418.png" alt="image-20241025153311418" style="zoom:67%;" />

> P1_7:第一行
>
> P1_6:第二行W
>
> P1_5:第三行
>
> p1_4:第四行
>
> P1_3:第一列
>
> P1_2:第二列
>
> P1_1:第三列
>
> p1_0:第四列

矩阵键盘的扫描是**输入扫描**，以行或者列为单位，逐个扫描，快速循环这个过程，最终实现所有按键同时扫描。

按行扫描会与单片机上的蜂鸣器功能相冲突，所以**一般选择按列扫描。**

按列扫描选中过程
位选：P10-P13为输入部分，针脚默认状态1，所以要选择哪一列，就要给这一列对应的阵脚输入0。例如选择第一列，则P13为0，P12、P11、P10都为1。
段选：P14-P17为输出部分，针脚默认状态1，当按键按下时，作为输出的针脚和低电平相接，输出为0。例如按键S1按下时，P17口输出值为0。

MatrixKey.c：

```c
unsigned char MatrixKey(){
	unsigned char keyNum=0;
	P1=0xFF;
	P1_3=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);keyNum=1;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);keyNum=5;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);keyNum=9;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);keyNum=13;}
	P1=0xFF;
	P1_2=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);keyNum=2;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);keyNum=6;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);keyNum=10;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);keyNum=14;}
	P1=0xFF;
	P1_1=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);keyNum=3;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);keyNum=7;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);keyNum=11;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);keyNum=15;}
	P1=0xFF;
	P1_0=0;
	if(P1_7==0){Delay(20);while(P1_7==0);Delay(20);keyNum=4;}
	if(P1_6==0){Delay(20);while(P1_6==0);Delay(20);keyNum=8;}
	if(P1_5==0){Delay(20);while(P1_5==0);Delay(20);keyNum=12;}
	if(P1_4==0){Delay(20);while(P1_4==0);Delay(20);keyNum=16;}
	return keyNum;
}
```

密码锁：

```c
#include "LCD1602.h"
#include "MatrixKey.h"

unsigned char KeyNum;
unsigned int Password,Count;

void main()
{
	LCD_Init();
	LCD_ShowString(1,1,"Password:");
	while(1)
	{
		KeyNum=MatrixKey();
		if(KeyNum)
		{
			if(KeyNum<=10)	//如果S1~S10按键按下，输入密码
			{
				if(Count<4)	//如果输入次数小于4
				{
					Password*=10;				//密码左移一位
					Password+=KeyNum%10;		//获取一位密码
					Count++;	//计次加一
				}
				LCD_ShowNum(2,1,Password,4);	//更新显示
			}
			if(KeyNum==11)	//如果S11按键按下，确认
			{
				if(Password==2345)	//如果密码等于正确密码
				{
					LCD_ShowString(1,14,"OK ");	//显示OK
					Password=0;		//密码清零
					Count=0;		//计次清零
					LCD_ShowNum(2,1,Password,4);	//更新显示
				}
				else				//否则
				{
					LCD_ShowString(1,14,"ERR");	//显示ERR
					Password=0;		//密码清零
					Count=0;		//计次清零
					LCD_ShowNum(2,1,Password,4);	//更新显示
				}
			}
			if(KeyNum==12)	//如果S12按键按下，取消
			{
				Password=0;		//密码清零
				Count=0;		//计次清零
				LCD_ShowNum(2,1,Password,4);	//更新显示
			}
		}
	}
}

```



### 定时器

STC89C52RC中含有的定时器个数为3个，即T0、T1、T2，其中T0和T1与传统的51单片机兼容，T2则是该型号的单片机增加的资源。

定时器在工作时，内部的时钟提供脉冲信号，计数单元每接收到一个脉冲信号，技术单元的数值就加一，当计数单元的数值到达了设定的阈值时，就会向中断系统发出中断申请，在中断系统中实现中断操作。

 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/51c9efd58c9048809acc7495284d2856.png)

#### 中断系统

中断源的个数为8个（外部中断0、定时器0中断、外部中断1、定时器1中断、串口中断、外部中断2、外部中断3）
 中断级个数4个。

#### 定时器的工作模式

定时器有四种工作模式：
 模式0：13位定时器/计数器
 模式1：16位定时器/计数器（**常用**）
 模式2：8位自动重装模式
 模式3：两个8位计数器

##### 模式1

##### 

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/886581cdfbf946bc8ee85ff8a7f72733.png)

    sysclk：单片机内置时钟。它从晶振中获取脉冲（即晶振周期，看开发板上晶振上的标识）来进行计时。
    MCU in 12T/6T mode：分频操作。即输入若是12Hz，经此会经行12/12或者12/6的操作。
    C/一横T：选择开关。C/一横T赋值为0，和MCU in 12T/6T mode口相连，进入timer模式，即定时器模式；C/一横T赋值为1，和T0 Pin口相连，进入counter模式，即计数器模式。

sysclk获取脉冲信号，经过MCU in 12T/6T mode进行分频操作，获得处理后的脉冲信号，发送到计数单元，每接收到一个脉冲信号技术单元的数值就加一，当计数单元的数值到达了设定的阈值时，就会通过TF0口，向中断系统发出中断申请，在中断系统中实现中断操作。

#### 相关寄存器*6

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f18f56a18ef44532b6e3a54ed795d794.png)

------

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/80f14637ef114c1f87877acf203dacc2.png)

**TCON（定时器中断控制寄存器）**

> TF0：**定时器T0溢出中断标志**。T0被允许允许计数以后，**从初值开始加1计数**，当**最高位产生溢出时，由硬件置“1”TF0**，向CPU发送中断请求，一直保持CPU响应该中断时，才由硬件清“0”TF0。该口**只需要检测它的值**。//计数至寄存器上限时，TF0==1，标志中断发出，CPU响应中断后，TF0==0，标志中断已消除
> TR0：**定时器T0**的**运行控制位**。当**TR0=1时允许T0开始计数，TR0=0时禁止T0计数**。

------

 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c50d820c877d4d44b37ed5f0068fbbb5.png)

**定时器工作模式寄存器TMOD**

> GATA：控制中断。可以由GATA单独控制，也可以由它和一横INTO共同控制。参看原理图可知，当**GATA为0**时，为GATA单独控制。（单看电路图的话，这部分涉及与门、或门和非门的知识）
> C/一横T：控制定时器用作定时器或计数器，**清零**则用作定时器 (从内部系统时钟输入)，置1用作计数器(从T0/P3.4脚输入)。
> M1、M0：用于模式选择。当**M1配置为0，M0配置为1**时，定时器工作模式为模式1。
>
> 需要注意的是，TMOD为不可位寻址，配置时需进行整体赋值。

------



> **TL0**和**TH0**：定时器0的计数单元。TL0和TH0分别表示一个数转化为二进制后的**低八位和高八位**，当低八位计数记满了之后，向高八位进一位。初始化时可将其赋值为0-65535的数字，如TL0=64614%256;TH0=64614/256;将低八位数字赋给TL0，将高八位数字赋给TH0

------

------

##### 中断寄存器

<img src="https://i-blog.csdnimg.cn/direct/8a5fb6ac8541493bbe82e8e12fb457fe.png" alt="在这里插入图片描述" style="zoom: 67%;" />
 <img src="https://i-blog.csdnimg.cn/direct/00171e91fb714bd8af20c271ca6c2d0e.png" alt="在这里插入图片描述" style="zoom:50%;" />

<img src="https://i-blog.csdnimg.cn/direct/ee6812cc5990491cb078d9221f4f5018.png" alt="这里是引用" style="zoom:50%;" />

>  **EA**：CPU的总中断允许控制位，**EA=1，CPU开放中断**，EA=0，CPU屏蔽所有的中断申请。EA的作用是使中断允许形成两极控制。即各中断源首先受EA控制;其次还受各中断源自
>  己的中断允许控制位控制。
>  **ET和EX**：定时器的溢出中断允许位。1为打开

<img src="https://i-blog.csdnimg.cn/direct/c44c70ae507e49c899235a04670bbf3f.png" alt="在这里插入图片描述" style="zoom:50%;" />
 参考下方：<img src="https://i-blog.csdnimg.cn/direct/7ba8ae34b0bd453b824a9945b1d4f816.png" alt="在这里插入图片描述" style="zoom:50%;" />

------

------

**时钟周期，机器周期**

寄存器加1经过了多少时间
例如；晶振频率为**11.0592MHZ**
时钟周期=1\11.0592us，**机器周期=时钟周期*12**=12\11.0952=1.085us(寄存器加1就是这里的时间)，并且每走一个机器周期等于寄存器走一位，这里时两个八位为16位的二进制2 ^ 16 =65536。
走完的时间为65536*1.085=71ms
如何定义10ms
这里如果想要定义10ms，不能让它从0开始计时，需要10/1.085=9620(10ms需要多少的数)所以必需要从65536-9620=56320开始，56320是寄存器开始的位，转化为十六进制位即DC00
低位 TL0=0x00
高位 TH0=0xDC

经过10ms，计数至65536，计时器发出中断。

**对于配置TMOD的配置的优化**
如果同时调用定时器0和定时器1时，用上述方式赋值将对定时器1产生影响。
`TOMD=TOMD|0x01;//把最低位置1`

定时器初始化

```c
void Timer0_Init() //11.0592GHZ
{
	// TOMD=0x01;       //0000 0001,选中定时器1，置为计时器状态
	TOMD=TOMD&0xF0;   //把TMOD的低四位清零，高四位保持不变，不影响定时器1
	TOMD=TOMD|0x01;   //把TMOD最低位置1，高四位保持不变，设置定时器0为开启状态
	TF0=0;           //将溢出中断标志清0
	TR0=1;           //开始计时
	TL0 = 0x66;		//设置定时初值0x66为十六进制，用于设置低八位的二进制
	TH0 = 0xFC;		//设置定时初值0xFC为十六进制，用于表示高八位的二进制，此时表示数字为64614，计满1ms则发出中断
	ET0=1;          //定时器0的溢出中断允许位。1为打开
	EA=1;            //设置CPU开放中断，置0则不开放中断
	PT0=0;           //设置优先级为最低
}

```

```c
void main()
{
	Timer0_Init();
	while(1)
	{
		
	}
}
```

当计数溢出时，程序中断，编写中断函数，实现此时要产生的功能。
当发生中断时TH0和TL0溢出，下一次计时要对TH0和TL0进行重新赋值为64614。
引入变量T0Count，每中断一次，即每计满1ms使得T0Count加1，因为1s=1000ms，所以当T0Count为1000时，即为1s的时间到了。可以设置一个判断语句来判断当前时间是否到了1s。

**中断号可参考下图。**
 ![img](https://i-blog.csdnimg.cn/direct/aa96397dba404ccf9c491fdd0f40ba0c.png)

**中断函数：**

```c
void Timer0_Routine() interrupt 1  //溢出时中断
{
	static int T0Count;//静态变量
	TL0 = 0x66;//重新设置初始值	 
	TH0 = 0xFC;//重新设置初始值
	T0Count++;
	if(T0Count>=1000)
	{
		T0Count=0;
		
	}		
}
```

定时器控制LED移位：

```c
#include <REGX52.H>
#include "Delay.h"
#include "Key.h"
#include <INTRINS.h>
#include "Timer0.h"

unsigned char KeyNum,LEDMod;

void main()
{
	P2=0xFE;
	Timer0_Init();
	while(1)
	{
		KeyNum=Key();
		if(KeyNum){
			LEDMod++;
			if(LEDMod>=2) LEDMod=0;
		}
	}
}
	
void Timer0_Routine() interrupt 1  //溢出时中断
{
	static int T0Count;//静态变量
	TL0 = 0x66;//重新设置初始值	 
	TH0 = 0xFC;//重新设置初始值
	T0Count++;
	if(T0Count>=1000)
	{
		T0Count=0;
		if(LEDMod==1) P2=_crol_(P2,1);  //循环左移一位
		if(LEDMod==0) P2=_cror_(P2,1);  //循环右移一位
	}		
}
```

定时器时钟

```c
#include <REGX52.H>
#include "LCD1602.h"
#include "Timer0.h"

unsigned char h,m,s,isChanged;
void main(){
	LCD_Init();
	Timer0_Init();
	LCD_ShowString(1,1,"  :  :  ");
	while(1){
		if(isChanged){
		LCD_ShowNum(1,1,h,2);
		LCD_ShowNum(1,4,m,2);
		LCD_ShowNum(1,7,s,2);
		isChanged=!isChanged;
		}
	}

}


void Timer0_Routine() interrupt 1  //溢出时中断
{
	static int T0Count;//静态变量
	TL0 = 0x66;//重新设置初始值	 
	TH0 = 0xFC;//重新设置初始值
	T0Count++;

	if(T0Count>=1000)
	{
		T0Count=0;
		s++;
		if(s>=60) {s=0;m++;}
		if(m>=60) {m=0;h++;}
		if(h>=24) {h=0;}
		isChanged=!isChanged;
	}		
}

```

### 串口通信

串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信。
 51单片机内部自带的**UART**(通用异步收发器)，可以实现串口通信。

#### 硬件电路

简单的双向串口通信有两根通信线（发送端TXD和接受端RXD）。

 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c104b9e9c82c4dfcb18d41465cac116a.png)

- TXD和RXD要交叉连接。因为从一个设备的发送端发送数据，对于另一个设备而言是输入值，要从接收端进入。
- 当电平标准不一致时，需要加电平转换芯片。

电平标准：数据1和数据0的表达方式，是传输线缆中认为规定的电压与数据的对应关系。

串口常用的电平标准：

    TTL电平（单片机用）：+5V 表示1，0V 表示0。
    RS232电平：-3 ~ -15V 表示1，+3 ~ +15V 表示0。
    RS485电平：两线压差+2 ~ +6V表示1， -2 ~ -6V 表示0。
#### 常见的通信接口比较

| 名称       | 引脚定义             | 通信方式     | 特点           |
| ---------- | -------------------- | ------------ | -------------- |
| **UART**   | TXD、RXD             | 全双工、异步 | 点对点通信     |
| **I^2C**   | SCL、SDA             | 半双工、同步 | 可挂载多个设备 |
| **SPI**    | SCLK、MOSI、MISO、CS | 全双工、同步 | 可挂载多个设备 |
| **1-Wire** | DQ                   | 半双工、异步 | 可挂载多个设备 |

此外还有：CAN（多用于汽车）、USB等

相关术语：

全双工：通信双方可以**同一时刻互相传输**数据。例如，手机。
半双工：通信双方可以**互相传输**数据，但必须**分时复用同一根数据线**。例如，对讲机。
单工：通信双方只能有一方发送到另一方，**不能反向传输**。例如，遥控器。
异步：通信双方**各自约定通信速率**。
同步：通信双方**靠一根时钟线来约定**通信速率。
总线：**连接各个设备的数据传输线路**。

#### UART的四种工作模式

模式0：同步移位寄存器 
**模式1：8位UART，波特率可变（常用）** 
模式2：9位UART，波特率固定 
模式3：9位UART，波特率可变

#### 串口通信原理图

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241105234408586.png" alt="image-20241105234408586" style="zoom:67%;" />

#### 串口参数以及时序图

**波特率**：串口通信的速率（发送和接收各数据位的间隔时间）
 **检验位**：用于数据验证
 **停止位**：用于数据帧间隔

 <img src="https://i-blog.csdnimg.cn/direct/8aac400b9f4140f28efd80691ce82fa0.png" alt="在这里插入图片描述" style="zoom:50%;" />

#### 串口模式图

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1c8ca2eecff344378413a06b80ec513f.png)
 左边为总线，数据只要到了总线，CPU才能进行相关操作。
 数据通过TXD发出；数据通过RXD进入。

**SBUF**：**串口数据寄存器**，物理上是两个单独的寄存器，但占用相同的地址。写操作时，写入的是发送寄存器，读操作时，独处的是接收寄存器。

#### 串口相关寄存器

<img src="https://i-blog.csdnimg.cn/direct/004f4b767ccc4e1da738214927f470cc.png" alt="在这里插入图片描述" style="zoom:67%;" />
 <img src="https://i-blog.csdnimg.cn/direct/00171e91fb714bd8af20c271ca6c2d0e.png" alt="在这里插入图片描述" style="zoom:67%;" />



> SCON：串行控制寄存器
>
> <img src="https://i-blog.csdnimg.cn/direct/8885bf95f6a943e39113aea0b735711f.png" alt="这里是引用" style="zoom:67%;" />
>
> SM0/SM1：SM0/FE：当PCON寄存器中的SMOD0/PCON.6位为1时，该位用于帧错误检测。当检测到一个无效停止位时，通过UART接收器设置该位。它必须由软件清零。
> 当PCON寄存器中的SMOD0/PCON.6位为0时，该位和SM1一起指定串行通信的工作 方式，如下表所示：
>
> SM2：允许方式2或方式3多机通信控制位。在方式1和方式0中，SM2配置为0。
> REN：允许/禁止串行接收控制位。由软件置位REN，即REN=1为允许串行接收状态，可启动串行接收器RxD，开始接收信息。软件复位REN，即REN=0，则禁止接收。
> TB8：在方式2或方式3，它为要发送的第9位数据，按需要由软件置位或清0。
> RB8：在方式2或方式3，是接收到的第9位数据。
> TI：**发送中断标志**。发送结束，内部硬件自动将T1置1，向主机请求中断，相应结束后，必须用软件复位T1，使T1置0。
> RI：接收中断请求标志。和T1类似。
>
> <img src="https://i-blog.csdnimg.cn/direct/8ede9d454d654552962fd0a3a410261d.png" alt="在这里插入图片描述" style="zoom: 80%;" />
>
> PCON：电源控制寄存器这里是引用
> SMOD：波特率选择位。当SMOD为1时，波特率加倍。
> SMOD0：帧错误检测有效控制位。当SMOD0为1时，开启真错误检测。

> **PCON：电源控制寄存器**
>
> <img src="https://i-blog.csdnimg.cn/direct/ef727a06914a4d9db3752a437ee2a030.png" alt="这里是引用" style="zoom:67%;" />**SMOD**：波特率选择位。当SMOD为1时，波特率加倍。
> **SMOD0**：帧错误检测有效控制位。当SMOD0为1时，开启帧错误检测。

![image-20241107234855988](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241107234855988.png)

#### 串口向电脑发送数据

给串口进行初始化配置，配置为模式1。
 注意，在配置波特率时，需要调用定时器，此处对于计时器只能调用计时器1，而且要配置为八位重装模式，参考9和手册。也可以直接用stc-isp中生成。但是需要注意的是STC89C52系列单片机中无AUXR，所以对于生成代码需要删除AUXR。

```c
//串口初始化
void UartInit(void)		//4800bps@11.0592MHz
{
	PCON &= 0x7F;		//波特率不倍速 0111 1111 使第一位变为低电平
	SCON = 0x50;		//8位数据,可变波特率 0101 0000
	TMOD &= 0x0F;		//清除定时器1模式位 0000 1111 使前四位变为低电平
	TMOD |= 0x20;		//设定定时器1为8位自动重装方式 0010 0000，使第三位变为高电平
	TL1 = 0xFA;		//设定定时器1低八位初值 1111 1010
	TH1 = 0xFA;		//设定定时器1重装值 1111 1010
	ET1 = 0;		//禁止定时器1中断
	TR1 = 1;		//启动定时器1
}

//串口发送数据
void Uart_SendByte(unsigned char Byte)
{
	SBUF=Byte;
	while(TI==0);//发送中断后，T1==1，循环结束
	TI=0;//T1重新置1
}
```

#### 电脑通过串口控制LED

```c
void UartInit_Device(void)		//4800bps@11.0592MHz
{
	PCON &= 0x7F;		//波特率不倍速
	SCON = 0x50;		//8位数据,可变波特率
	TMOD &= 0x0F;		//清除定时器1模式位
	TMOD |= 0x20;		//设定定时器1为8位自动重装方式
	TL1 = 0xFA;		//设定定时初值
	TH1 = 0xFA;		//设定定时器重装值
	ET1 = 0;		//禁止定时器1中断
	TR1 = 1;		//启动定时器1
	//添加串口中断
	EA=1;
	ES=1;       //设置串口开放中断
}
/*
void UART_Routine(void) interrupt 4
{
	if(RI==1)      //单片机接收中断
  {
		P2=SBUF;
		Uart_SendByte(SBUF);
		RI=0;
	}
}
*/
```

```
#include <REGX52.H>
#include <Delay.h>
#include <UART.h>

unsigned char sec;
unsigned i =0;

void main()
{
	P2=0xFE;
	UartInit_Device();
	while(1)
	{
		
	}
}

void UART_Routine(void) interrupt 4
{
	if(RI==1)      //单片机接收中断
	{
		i++;
		if(i>=7){i=0;}
		P2=~(0x01<<i);//串口中断控制LED移位
		Uart_SendByte(SBUF);
		RI=0;
	}
}
```

### LED点阵屏

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241108140145242.png" alt="image-20241108140145242" style="zoom:67%;" />

选中列P0？给0。P0_7~P0_0：1~8列
选中行，要调用74HC595模块，实现DP？输出为1。
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/722f346491f84bcc8e231f761fe37e7c.png)

#### 74HC595

> **串行输入并行输出**的移位寄存器
> 可用**3根线输入串行数据**，**8根线输出并行数据**，**多片级联**后，可输出16位、24位、32位等，常用于IO口扩展。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ba3344f04f0249129a0db8c1cb1ee7aa.png)

相关引脚:

> P3_5**RCLR/SRCLR**：串行清零端。给高电平（1）实现数据移位。
> P3_6**SERCLR/一横SRCLR**：串行时钟,实现数据下行
> P3_4**SER**：串行数据
> 用SER输入一个字符，SERCLK使得数据下移（可以参考栈），当数据达到八位时，RCLK（SRCLK）将数据移动到输出各引脚。

1. 实现选中行
   引入输入值变量Byte，**一次性输入八位**，对sec进行赋值。参考11.1，**SER先取最高位**，可以用逻辑与。因为SER只存储一位数据，所以当Byte进行逻辑与运算时，**SER最后得到的值非0即1**，则**SER实际得到的值是Byte与给出的数进行逻辑与运算后是否相同的判断值，若是相同则为1，若是不同则为0**，以此取得Byte最高位。
   数据存入后，要用SERCLK使得数据下移，为下一位数据的存入腾出空间。
   如此循环八次，可以用for循环进行优化。
   八位数字全部获取后，用SRCLK实现输出。
   需要注意的是，**为了避免针脚在调用前已经有非0值，需要在调用该针脚前进行清零操作**，可以在主函数中进行。
   实现以上操作可以选中行。

```c
void _74HC595_WriteByte(unsigned char Byte) //写入数据
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		P3_4=Byte&(0x80>>i);   //依次取Byte各位值赋给SER
		P3_6=1;                //一横SRCLR,实现数据下行
		P3_6=0;
	}
	P3_5=1;        //SRCLK,实现输出
	P3_5=0;
}

```

2. 实现选中列，对P0进行操作，可以参考5.2，也可以用移位进行优化。

```c
void MatrixLED_ShowColumn(unsigned char Column,Data){
	_74HC595_WriteData(Data);
	P0=~(0x80>>Column);
	Delay(1);
	P0=0xFF;
	
}
```

```c
//Matrix.h
#include <REGX52.H>
#include "Delay.h"

/*74HC595_Init:
P3_6=0;
P3_5=0;
*/
void _74HC595_WriteData(unsigned char Byte){
	unsigned char i;
	for(i=0;i<8;i++){
		P3_4=Byte&(0x80>>i);
		P3_6=1;  //下移
		P3_6=0;
	}
	P3_5=1;	//右移
	P3_5=0;
}


void MatrixLED_ShowColumn(unsigned char Column,Data){
	_74HC595_WriteData(Data);
	P0=~(0x80>>Column);
	Delay(1);
	P0=0xFF;
	
}
```

显示静态图案：

```c
#include <REGX52.H>
#include "MatrixLED.h"
#include <Delay.h>


void main()
{
	P3_6=0;
	P3_5=0;
	while(1)
	{
		MatrixLED_ShowColumn(0,0x3C);
		MatrixLED_ShowColumn(1,0x42);
		MatrixLED_ShowColumn(2,0xA9);
		MatrixLED_ShowColumn(3,0x85);
		MatrixLED_ShowColumn(4,0x85);
		MatrixLED_ShowColumn(5,0xA9);
		MatrixLED_ShowColumn(6,0x42);
		MatrixLED_ShowColumn(7,0x3C);
	}
}

```

#### 显示动画

```c
#include <REGX52.H>
#include "MatrixLED.h"
#include <Delay.h>

unsigned char code Animatio[]={
0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0x08,0x08,0x08,0xFF,0x00,0x5F,
0x00,0xFD,0x00,0x00,0x00,0x00,0x00
};

void main()
{
	unsigned int i,offset=0,count=0;
	
	MatrixLED_Init();
	
	while(1) 
	{
		for(i=0;i<8;i++) MatrixLED_ShowColumn(i,Animatio[i+offset]);
		count++;
		if(count==10)
		{
			offset++;
			count=0;
			if(offset>=16)
			{
				offset=0;
			}
		}
	}
}

```

### DS1302

具有涓细电流充电能力的低功耗实时时钟芯片。它可以对年、月、日、周、时、分、秒进行计时，且具有闰年补偿等多种功能。
 RTC：实时时钟，是一种集成电路，通常称为时钟芯片。

#### 应用电路

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a98ad591db3b4743978714a3ee4a22cd.png)

> VCC2：主电源
> VCC1：备用电池//没有
> GND：电源地
> X1、X2：32.768KHz晶振
> P3_5 CE：芯片使能
> P3_4 IO：数据输入/输出
> P3_6 SCLK：串行时钟

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241108154137042.png" alt="image-20241108154137042" style="zoom:67%;" />

时钟相关寄存器

<img src="https://i-blog.csdnimg.cn/direct/bdd1dddcda294ad69322bc1ce343c0c5.png" alt="在这里插入图片描述" style="zoom:67%;" />

命令字

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/988c8c22bfd34b5c9c9ae21571a6d08b.png)

> 位 7：必须是**逻辑 1**. 如果是 0, 则禁止对 DS1302写入。
> 位 6： 在逻辑 0时规定为时钟/日历数据,逻辑 1时为 RAM数据。
> 位 1 至 位 5： 表示了输入输出的指定寄存器。
> 位 0： 在**逻辑0时为写**操作,**逻辑1时为读**操作.命令字以 LSB (位 0)开始总是输入。

#### 时序定义

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cd28f3e86303439386d7389d2251d71f.png)

```c
sbit DS1302_SCLK=P3^6;/时钟
sbit DS1302_IO=P3^4;//输入输出
sbit DS1302_CE=P3^5;//使能

void DS1302_Init(void)
{
	DS1302_CE=0;
	DS1302_SCLK=0;
}
```

```c
void DS1302_WriteByte(unsigned char Command,Data)
{
	unsigned char i;
	DS1302_CE=1;
	
	for(i=0;i<8;i++)//输入命令字
	{
		DS1302_IO=Command&(0x01<<i);
		DS1302_SCLK=1;
		DS1302_SCLK=0;
	}
	for(i=0;i<8;i++)//输入数据
	{
		DS1302_IO=Data&(0x01<<i);
		DS1302_SCLK=1;
		DS1302_SCLK=0;
	}
	DS1302_CE=0;
}
```

写入比读取多以一个脉冲，当运行到第八位时，到对应脉冲的下降沿立即输出，进入第二个数据的第一位（即输出的第一位），但是此时的输出值我们并没有获取，所以实际输出时跳过了这个值 。所以，在进入输出的第一位数据时，要及时暂停，使输入命令后的第一个下降沿时就读取数据**。

```c
unsigned char DS1302_ReadByte(unsigned char Command)
{
	unsigned char i，Data=0x00;
	DS1302_CE=1;
	
	for(i=0;i<8;i++)
	{
		DS1302_IO=Command&(0x01<<i);
		DS1302_SCLK=0;
		DS1302_SCLK=1;
	}
	for(i=0;i<8;i++)
	{
		DS1302_SCLK=1;
		DS1302_SCLK=0;
		if(DS1302_IO){Data|=(0x01<<i)};
	}
	DS1302_CE=0;
	DS1302_IO=0;
	return(Data);
}
```

在主函数中调用函数。
 先对LCD1602进行操作，输出提示字。
 参考12.1.4，进行写操作时，位0为0，位6为0，位7为1。进行读操作时位0为1，位6为0，位7为1。
 参考12.1.3，对秒、分、时进行设定。
 用LCD1602呈现结果。

> 读出时间为一个大于59并且不动的数时，芯片可能处于读写保护状态，要加
> DS1302_WriteByte(0x8E,0x00);
> 解除保护。

#### BCD与十进制转化

> 显示结果到9之后直接跳转到16，因为在DS1302中采用BCD码（用四位二进制数来表示1位十进制数，可以简单的理解为取去除了abcd等字母的十六进制）存储，所以我们还需要了解BCD码和十进制之间的转换关系：
> 1.BCD码转十进制：
> DEC=BCD/16*10+BCD%16（2位）
>
> 2.十进制换BCD码：
> BCD=DEC/10*16+DEC%10（2位）

```C
//DS1302.c
#include <REGX52.H>

//引脚定义
sbit DS1302_SCLK=P3^6;//时钟
sbit DS1302_IO=P3^4;//IO口
sbit DS1302_CE=P3^5;//使能

//寄存器写入地址/指令定义
#define SECONDS 0x80
#define MINUTES 0x82
#define HOUR 0x84
#define DATE 0x86
#define MONTH 0x88
#define DAY 0x8A
#define YEAR 0x8C
#define WP 0x8E//写保护

//年 月 日 时 分 秒 星期
unsigned char Time[]={24,11,8,20,10,50,5};

/**
  * @brief DS1302初始化
  * @param 无
  * @retval 无
  */
void DS1302_Init(void){
	DS1302_SCLK=0;
	DS1302_CE=0;
}

/**
  * @brief DS1302写数据
  * @param Command 命令字/地址
  * @param Data 数据
  */
void DS1302_WriteData(unsigned Command,Data){
	unsigned i;
	DS1302_CE=1;
	for(i=0;i<8;i++){
		DS1302_IO=Command&(0x01<<i);
		DS1302_SCLK=0;
		DS1302_SCLK=1;
	}
	for(i=0;i<8;i++){
		DS1302_IO=Data&(0x01<<i);
		DS1302_SCLK=0;
		DS1302_SCLK=1;
	}
	DS1302_CE=0;
}

/**
  * @brief DS1302读数据
  * @param Command 命令字/地址
  * @retval Data 数据
  */
unsigned char DS1302_ReadData(unsigned Command){
	unsigned i,Data=0x00;
	Command|=0x01;//将各个写入地址+1得到读取地址
	DS1302_CE=1;
	for(i=0;i<8;i++){
		DS1302_IO=Command&(0x01<<i);
		DS1302_SCLK=0;
		DS1302_SCLK=1;
	}
	for(i=0;i<8;i++){
		DS1302_SCLK=1;
		DS1302_SCLK=0;
		if(DS1302_IO){Data|=(0x01<<i);}//IO接受1，则将1写入Data对应位数
	}
	DS1302_CE=0;
	DS1302_IO=0;//读取后将IO设置为0，否则读出的数据会出错
	return Data;
}

/**
  * @brief DS1302设定时间
  * @param 无
  * @retval 无
  */

void DS1302_SetTime(void){
	DS1302_WriteData(WP,0x00);
	DS1302_WriteData(YEAR,Time[0]/10*16+Time[0]%10);//Time[0]/10为十位上的数字,*16+个位上的数字(Time[0]%10),得出BCD码表示时的值
	DS1302_WriteData(MONTH,Time[1]/10*16+Time[1]%10);
	DS1302_WriteData(DATE,Time[2]/10*16+Time[2]%10);
	DS1302_WriteData(HOUR,Time[3]/10*16+Time[3]%10);
	DS1302_WriteData(MINUTES,Time[4]/10*16+Time[4]%10);
	DS1302_WriteData(SECONDS,Time[5]/10*16+Time[5]%10);
	DS1302_WriteData(DAY,Time[6]/10*16+Time[6]%10);
	DS1302_WriteData(WP,0x00);
}

/**
  * @brief DS1302读取时间
  * @param 无
  * @retval 无
  */

void DS1302_ReadTime(void){
	unsigned char Temp;
	Temp=DS1302_ReadData(YEAR);
	Time[0]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadData(MONTH);
	Time[1]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadData(DATE);
	Time[2]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadData(HOUR);
	Time[3]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadData(MINUTES);
	Time[4]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadData(SECONDS);
	Time[5]=Temp/16*10+Temp%16;
	Temp=DS1302_ReadData(DAY);
	Time[6]=Temp/16*10+Temp%16;
}
```

```C
//DS1302.h
#ifndef __DS1302_H__
#define __DS1302_H__

extern unsigned char Time[];//extern关键字用于使用其他文件的变量

void DS1302_Init(void);
void DS1302_WriteData(unsigned Command,Data);
unsigned char DS1302_ReadData(unsigned Command);
void DS1302_SetTime(void);
void DS1302_ReadTime(void);

#endif

```



```C
//main.c
#include <REGX52.H>
#include "DS1302.h"
#include "LCD1602.h"

void main(){
	LCD_Init();
	DS1302_Init();
	LCD_ShowString(1,1,"  /  /  ");
	LCD_ShowString(2,1,"  :  :  ");
	DS1302_SetTime();
	while(1){
		DS1302_ReadTime();
		LCD_ShowNum(1,1,Time[0],2);
		LCD_ShowNum(1,4,Time[1],2);
		LCD_ShowNum(1,7,Time[2],2);
		LCD_ShowNum(2,1,Time[3],2);
		LCD_ShowNum(2,4,Time[4],2);
		LCD_ShowNum(2,7,Time[5],2);
		LCD_ShowNum(1,10,Time[6],1);
	}
}
```

### 蜂鸣器

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241110130546279.png" alt="image-20241110130546279" style="zoom:67%;" />![image-20241110130638482](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241110130638482.png)

P25控制BEEP的输出。BEEP输出为低电平时，蜂鸣器工作。

蜂鸣器播放特定频率的声音：

每隔半周期取反，可用定时器中断函数做到。

定时器每次加一的时间为12/11.0592=1.085us
65566-半周期/1.085即为赋给TL0和TH0的初始值

```
void Timer0_Routine() interrupt 1  //溢出时中断
{
	TL0 = FreqTable[FreqSelect]%256;//FreqTable[FreqSelect]是简谱中的一个音调的半个周期		 
	TH0 = FreqTable[FreqSelect]/256;
	BEEP=!BEEP;
}
```

```
#include <at89c51RC2.h>
#include <Timer0.h>
#include <Delay.h>

sbit BEEP=P2^5;

//三组 1 1# 2 2# 3 4 4# 5 5# 6 6# 7 一行12个
//超出内存大小时在变量名前使用code关键字，将变量存储于ROM中
unsigned int FreqTable[]={
	63777,63872,63969,64054,64140,61216,64291,64360,64426,64489,64547,64607,
	64655,64704,64751,64795,64837,64876,64913,64948,64981,65012,65042,65070,
  65095,65120,65144,65166,65186,65206,65255,65242,65259,65274,65289,65303
}  ;//各个音符对应的重装载值

unsigned int Music[]={12,12,19,19,21,21,19,17,17,16,16,14,14,12};//简谱上各音符对应重装载值的位置
unsigned char Music_Time[]={500,500,500,500,500,500,1000,500,500,500,500,500,500,1000};//各音符对应时长

unsigned int FreqSelect,MusicSelect,Music_TimeSelect;

void main()
{
	Timer0_Init();
	while(1)
	{
		if(Music[MusicSelect]!=0xFF && Music_Time[Music_TimeSelect]!=0xFF)
		{
		FreqSelect=Music[MusicSelect];
		MusicSelect++;
		Delay(Music_Time[Music_TimeSelect]);
		Music_TimeSelect++;
		TR0=0;
		Delay(5);
		TR0=1;
		}
		else
		{
			TR0=0;
			while(1);
		}
	}
}

void Timer0_Routine() interrupt 1  //溢出时中断
{
	TL0 = FreqTable[FreqSelect]%256;		 
	TH0 = FreqTable[FreqSelect]/256;
	BEEP=!BEEP;
}
```

### AT24C02（I2C总线）

>RAM：易失性存储器，存储速度快，断电丢失。
>SRAM（静态RAM）：D触发器，用电路储存。存储速度最快。
>DRAM（动态RAM）：用电容存储数据，需要搭配扫描电路。
>ROM：非易失性存储器，存储速度慢，断电不丢失。
>Mask ROM（掩膜ROM）：最早的ROM，只能读不能写。
>PROM（可编程ROM）：基于Mask ROM升级后的ROM，解决了只能读不能写的问题，但是只能编写一次。
>EPROM（可擦除可编程ROM）：基于PROM升级后的ROM，紫外线照射30分钟可以实现擦除。
>E2PROM（电可擦除可编程ROM）：基于EPROM升级后的ROM，可以依靠电信号擦除，相对于EPROM更加方便。
>Flash（闪存）
>硬盘、软盘、光盘

存储器在内部是电路的网状结构，存储器的简化模型如下图：
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b5c4e95252b54ae2ab7ba0a8493a5ba9.png)

> **地址总线**：横向的线。
>  **数据总线**：纵向的线。
>  从地址总线输入数据，根据结点的连接情况不同，数据总线得到的数据不同。

#### AT24C02

介绍

AT24C02是**掉电不丢失**的存储器，它的存储介质是**E2PROM**，通讯接口是**I2C总线**，容量为**256字节**。

其用途包括：

- **存储配置信息**：用于保存设备配置参数，如设备设置、用户偏好等，以便在设备重启后能够恢复这些设置。
- **保存程序数据**：存储程序运行过程中产生的数据，如计数值、状态标记等，以便在程序下次运行时能够继续之前的工作。
- **设备状态记录**：记录设备的状态信息，如故障记录、使用次数等，有助于设备的维护和故障诊断

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241110133928670.png" alt="image-20241110133928670" style="zoom:67%;" />

> **VCC、GND（8号和4号）**：电源（1.8V~5.5V）
>  **WP（7号）**：写保护。但是在此电路中直接接到了GND上，可以不用再配置。
>  **SCL、SDA**：I2C接口。
>  **A0、A1、A2（1号2号3号）**：I2C地址。

#### I2C总线

两根通信线为，SCL、SDA。

##### I2C电路规范

- 所有I2C设备的SCL连载一起，SDA连接在一起。
- 设备的SCL和SDA均要配置成**开漏输出**模式。
- SCL和SDA**各添加一个上拉电阻**，阻值一般为千欧级。
- 开漏输出和上拉电阻的共同作用实现了“线与”的功能，此设计主要是为了解决多机通信互相干扰的问题。

![image-20241110161326557](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241110161326557.png)

##### 时序结构

<img src="https://i-blog.csdnimg.cn/direct/1370d08028ae490aa9f6829e6d8b547d.png" alt="在这里插入图片描述" style="zoom:67%;" />

**起始条件**：SCL高电平期间，SDA从高电平切换到低电平。SDA切换完成后，把SCL也切换到低电平状态，可以避免时序的混乱。
 **终止条件**：SCL高电平期间，SDA从低电平切换到高电平。SCL先从低电平切换到高电平，切换完成后，再切换SDA，可以避免时序的混乱。

<img src="https://i-blog.csdnimg.cn/direct/a9d7b8d15df14932ad6bc5bc5507d64d.png" alt="在这里插入图片描述" style="zoom:67%;" />

> 发送一个字节：在SCL低电平期间，主机将数据位依次放到SDA线上（高位在前），然后拉高SCL，从机将**在SCL高电平期间读取数据位**，所以**SCL高电平期间SDA不允许有数据变化**，依次循环上述过程8次，即可发送一个字节。
>
> 简单来说，SCL会变化，高电位读取SDA数据一位，此时SDA保持稳定。SCL低位时，不读取，此时SDA需要改变数据，以供下轮读取。

<img src="https://i-blog.csdnimg.cn/direct/986e59cc1f954f02a45574a55399b267.png" alt="在这里插入图片描述" style="zoom:67%;" />

> **接收一个字节**：在SCL低电平期间，从机将数据位依次放到SDA线上（高位在前），然后拉高SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节（主机在接收之前，需要释放SDA）。

<img src="https://i-blog.csdnimg.cn/direct/f5008baddd4a4eb5bf8968747d472215.png" alt="在这里插入图片描述" style="zoom:67%;" />

>**发送应答**：在接收完一个字节后，主机在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答。
>**接收应答**：在发送完一个字节之后，主机在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）

#####  I2C数据帧

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a326201c1eb742deb251299c3519f086.png)

> **发送一帧数据**：由初始状态开始。再发送一个字节数据，这个字节数据必须是从机地址（前四位固定，STC89C52前四位是1010）＋读写位（1是读，0是写）。每发送一个字节都要跟一个接收应答。最后是终止条件。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/12776560a9284ae4bb2be15c488ad3e3.png)

> **接收一帧数据**：由初始状态开始。再发送一个字节数据，这个字节数据必须是从机地址（前四位固定，STC89C52前四位是1010）＋读写位（1是读，0是写）。每接收一个字节都要跟一个发送应答，最后一个应答一般为非应答（SA：1）。最后是终止条件。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/69f25c535e20451a8886d27bf68cdb6f.png)

>**复合格式**：由初始状态开始。再发送一个字节数据，这个字节数据必须是从机地址（前四位固定，STC89C52前四位是1010）＋读写位（1是读，0是写）。每发送一个字节都要跟一个接收应答。再发送一个字节数据，这个字节数据必须是从机地址（前四位固定，STC89C52前四位是1010）＋读写位（1是读，0是写）。每接收一个字节都要跟一个发送应答，最后一个应答一般为非应答（SA：1）。最后是终止条件。

#### AT24C02数据帧

AT24C02数据帧与I2C数据帧相似，但有所简化。
 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3a1aca0ffc244815bdea12629fdd55f8.png)

> **字节写**：在WORD ADDRESS处写入数据DATA。
>  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ec84f2f7e7734d2fa88ab57e719b435c.png)

<img src="https://i-blog.csdnimg.cn/direct/db668c50d4754db4922298f080304806.png" alt="在这里插入图片描述" style="zoom:67%;" />

> **随机读**：读出在WORD ADDRESS处的数据DATA。
>  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e7f7c8c38f2a45bbb60db83a1bb757e4.png)

AT24C02的固定地址为1010，可配置地址本开发板上为000，所以SLAVE ADDRESS+W为0xA0，SLAVE ADDRESS+R为0xA1。

#### AT24C02显示

```c
//I2C.c
#include <REGX52.H>

sbit I2C_SCL=P2^1;
sbit I2C_SDA=P2^0;

/**
  * @brief I2C开始
  * @param 无
  * @retval 无
  */
void I2C_Start(void){
	I2C_SDA=1;
	I2C_SCL=1;
	I2C_SDA=0;
	I2C_SCL=0;
}

/**
  * @brief I2C停止
  * @param 无
  * @retval 无
  */

void I2C_Stop(void){
	I2C_SDA=0;
	I2C_SCL=1;
	I2C_SDA=1;
}

/**
  * @brief I2C发送数据
  * @param Byte 发送的一个字节
  * @retval 无
  */

void I2C_SendByte(unsigned char Byte){
	unsigned char i;
	for(i=0;i<8;i++){
		I2C_SDA=Byte&(0x80>>i);
		I2C_SCL=1;
		I2C_SCL=0;
	}
}

/**
  * @brief I2C接收数据
  * @param 无
  * @retval 接收到的一个数据
  */

unsigned char I2C_ReceiveByte(void){
	unsigned char i,Byte=0x00;
	I2C_SDA=1;
	for(i=0;i<8;i++){
		I2C_SCL=1;
		if(I2C_SDA){Byte|=(0x80>>i);}
		I2C_SCL=0;
	}
	return Byte;
}

/**
  * @brief I2C发送应答
  * @param AckBit 应答位，0为应答，1为非应答
  * @retval 无
  */

void I2C_SendAck(unsigned char AckBit){
	I2C_SDA=AckBit;
	I2C_SCL=1;
	I2C_SCL=0;
}

/**
  * @brief I2C接收应答
  * @param 无
  * @retval 无
  */

unsigned char I2C_ReceiveAck(void){
	unsigned char AckBit;
	I2C_SDA=1;
	I2C_SCL=1;
	AckBit=I2C_SDA;
	I2C_SCL=0;
	return AckBit;

}
```

```c
//AT24C02.c
#include <REGX52.H>
#include "I2C.h"

#define AT24C02_ADDRESS_W 0xA0//1010 0000
#define AT24C02_ADDRESS_R 0xA1//1010 0001

/**
  * @brief AT24C02写入一个字节
  * @param Address 写入的地址
  * @param Data 写入的数据
  * @retval 无
  */

void AT24C02_WriteByte(unsigned char Address,Data){
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS_W);//先写入设备地址0
	I2C_ReceiveAck();
	I2C_SendByte(Address);//再写入设备内部寄存器地址
	I2C_ReceiveAck();
	I2C_SendByte(Data);//最后写入数据
	I2C_ReceiveAck();
	I2C_Stop();
}

/**
  * @brief AT24C02读取一个字节
  * @param Address 读取的地址
  * @retval Data 读出的一个字节
  */

unsigned char AT24C02_ReadByte(unsigned char Address){
	unsigned char Data;
	
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS_W);//先写入设备地址0
	I2C_ReceiveAck();
	I2C_SendByte(Address);//再写入设备内部寄存器地址
	I2C_ReceiveAck();
	
	I2C_Start();
	I2C_SendByte(AT24C02_ADDRESS_R);//最后读取数据
	I2C_ReceiveAck();
	Data=I2C_ReceiveByte();
	I2C_SendAck(1);
	I2C_Stop();
	
	return Data;
}
```

```c
//main.c
#include <REGX52.H>
#include "LCD1602.h"
#include "AT24C02.h"
#include "Delay.h"

unsigned char Data;

void main(){
	LCD_Init();
	AT24C02_WriteByte(0,0x66);
	Delay(5);//AT24C02的写周期为5ms
	Data=AT24C02_ReadByte(0);
	LCD_ShowNum(1,1,Data,3);
	while(1){
	
	}

}
```

```c
//main.c,按键控制读写
#include <REGX52.H>
#include "LCD1602.h"
#include "AT24C02.h"
#include "Delay.h"
#include "Key.h"

unsigned char KeyNum;
unsigned int Num;

void main(){
	LCD_Init();
	LCD_ShowNum(1,1,Num,5);
	while(1){
		
		KeyNum=Key();
		switch(KeyNum){
			case 1:Num++;LCD_ShowNum(1,1,Num,5);break;
			case 2:Num--;LCD_ShowNum(1,1,Num,5);break;
			case 3:
				AT24C02_WriteByte(0,Num/16);Delay(5);
				AT24C02_WriteByte(1,Num%16);Delay(5);
				LCD_ShowString(2,1,"Write Success!");
				Delay(1000);
				LCD_ShowString(2,1,"              ");
				break;
			case 4:
				Num=AT24C02_ReadByte(0)*16+AT24C02_ReadByte(1);
				LCD_ShowString(2,1,"Read Success!");
				LCD_ShowNum(1,1,Num,5);
				Delay(1000);
				LCD_ShowString(2,1,"              ");
				break;
		}
	}

}
```

### DS18B20（单总线）放弃了

一种常见的数字温度传感器，其控制命令和数据都是以数字信号的方式输出的，相比较与模拟温度传感器，具有功能强大、硬件简单、易扩展、抗干扰性强等特点。

> 测温范围：-55℃到+125℃
>  通信接口：1-Wire（单总线）

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241110200220161.png" alt="image-20241110200220161" style="zoom:67%;" />

> **VDD**：电源（3.0V ~ 5.5V）
> **GND**：电源地
> **I/O**：单总线接口

------

------



#### 15.1.1.2 内部结构框图

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b14fafe316a246ecb66437f5b686f26e.png)

#### 15.1.1.3 存储器结构

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1c05732196494b4e9a54de3c569334d1.png)

------

#### 单总线

单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线。

> 一根通信线：DQ
> 异步、半双工

单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线。

电路规范

- 设备的DQ均要配置成开漏输出模式。
- DQ添加一个上拉电阻，阻值一般为4.7KΩ左右
- 若此总线的从机采取寄生供电，则主机还应配一个强上拉输出电阻。

 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/800fb7faf8594fc387642c1bb2c00656.png)

##### 时序结构

**初始化**：主机将总线拉低至少480us，然后释放总线，等待15 ~ 60us后，存在的从机拉低总线60 ~ 240us以响应主机，之后从机将释放总线。

**发送一位**：主机将总线拉低60 ~ 120us，然后释放总线，表示发送0；主机将总线拉低1 ~ 15us，然后释放总线，表示发送1。从机将再总线拉低30us后读取电平，整个时间片大于60us。

**接收一位**：主机将总线拉低1 ~ 15us，然后释放总线，并且在拉低后15us内读为高电平则为接收1，整个时间片应大于60us。

##### 

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/30efa8c090f64d1fb6187c2b9fab61f7.png)

**发送一个字节**：连续调用8次发送一位的时序，依次发送一个字节的8位（低位在前）。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8ddc203791f14d609708e523e2b7884d.png)

**接收一个字节**：连续调用8次接收一位的时序，依次接收一个字节的8位（低位在前）。

#### 操作流程

先进行**初始化**，再进行**ROM操作**，最后是**功能操作**。

> **初始化**：从机复位，主机判断从机是否响应。
>  **ROM操作**：RO指令+本指令需要的读写操作。
>  **功能操作**：功能指令+本指令需要的读写操作。
>  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3d83b6919ed643788d64ca21afceca0a.png)

#### DS18B20数据帧

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/82e4c4513a644656bcf56076199f1f79.png)

> **温度变换**：先初始化，再跳过ROM，最后开始温度变换。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/11b09e2375164429a9944f7a61b19161.png)

> **温度读取**：先初始化，再跳过ROM，然后读暂存器，最后是连续的读操作。

#### 温度存储格式

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/871409849ece45bc8d05e0d096803be1.png)

> **LS BYTE**：低八位
> **MS BYTE**：高八位

将MS BYTE移动到LS BYTE前，构成16位二进制。

> **BIT0 ~ BIT3**：表示小数部分。
> **BIT11 ~ BIT15**：表示数字的正负性。当数值为负时，这几位全为1；当数值为正时，这几位全为0。

### 呼吸灯

```c
//main.c
#include <REGX52.H>

void Delay(unsigned int i)
{
	while(i--);
}

void main()
{
	unsigned char Time,i;
	P2_2=0;
	while(1)
	{
		for(Time=0;Time<100;Time++)
		{
			for(i=0;i<20;i++)
			{
				P2_0=0;P2_1=0;
				Delay(Time);
				P2_0=1;P2_1=1;
				Delay(100-Time);
			}
		}
		for(Time=100;Time>0;Time--)
		{
			for(i=0;i<20;i++)
			{
				P2_0=0;P2_1=0;
				Delay(Time);
				P2_0=1;P2_1=1;
				Delay(100-Time);
			}
		}
	}
}
```



### 直流电机驱动（PWM）

#### 直流电机介绍

直流电机是一种将电能转换为机械能的装置。
 直流电机主要由永磁体（定子）、线圈（转子）和转向器组成。
 除直流电机外，常见的电机有进步电机、舵机、无刷电机、空心电机等。

#### 电机驱动电路

##### 16.1.2.1 大功率器件直接驱动（单向）

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c66a9a43b93a4854a525025812861e27.png)

二极管作用：续流二极管，防止局部电压过高导致损坏

> 三极管基极低电平导通

##### 16.1.2.2 H桥驱动（可正可反）

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e5e8adcb84934572a4104cfafdd849e2.png)

要求晶体管或mos管有耐压特性

#### PWM

PWM（Pulae Width Modulation）即脉冲宽度调制，在**惯性的系统**中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要地模拟参量，常应用于电机控速、开关电源等领域。

![image-20241112202802942](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112202802942.png)

> **PWM重要参数**：
>  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3163bc53da1749d1a2deba7fb30a845a.png)

产生PWM的方法

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a02bb519ab7e4158b75afce2bd6be1c9.png)

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112203811066.png" alt="image-20241112203811066" style="zoom: 50%;" />

> 计数器定时自增和用户设置的比较值对比，对比结果不同，输出不同，产生方波，实现PWM输出。

#### 步进电机模块原理图

![image-20241111164436699](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241111164436699.png)

代码呈现：

```c
//main.c
#include <REGX52.H>
#include <Timer0.h>
#include <Key.h>
#include <Nixie.h>

sbit Motor=P1^0;//电机接入P1_0;P1_1;

unsigned char Counter,Compare;
unsigned char KeyNum,Speed=0;
 
void main()
{
	Motor=0;//在最开始要将引脚置0，不然电机插入后可能是处于旋转状态。
	Timer0_Init();
	while(1)
	{
		KeyNum=Key();
		if(KeyNum==1)
		{
			Speed++;
			Speed%=4;
			if(Speed==0) {Compare=0;}
			if(Speed==1) {Compare=50;}
			if(Speed==2) {Compare=75;}
			if(Speed==3) {Compare=100;}
		}
		Nixie(1,Speed);
	}
}

void Timer0_Routine() interrupt 1  //溢出时中断
{
	TL0 = 0xAE;		
	TH0 = 0xFB;
	Counter++;
	Counter%=100;    //Counter到100了
	if(Counter<Compare)
	{
		Motor=1;
	}
	else
	{
		Motor=0;
	}
}
```

### AD/DA

>AD（Analog to Digital）：模拟-数字转换，将模拟信号转换为计算机可操作的数字信号。
>DA（Digital to Analog）：数字-模拟转换，将计算机输出的数字信号转换为模拟信号。比较少，可用PWM替代
>
>光敏电阻，热敏电阻，可调电阻，麦克风，扬声器

AD/DA转换打开了计算机与模拟信号的大门，极大的提高了计算机系统的应用范围，也为模拟信号数字化处理提供了可能

#### 硬件电路模型

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112213200259.png" alt="image-20241112213200259" style="zoom: 80%;" />

- AD转换通常有多个输入通道，用多路选择开关链接至AD转换器，以实现AD多路复用的目的，提高硬件利用率。

- AD/DA与单片机数据传送可使用并口（速度快、原理简单），也可以使用串口（接线少、使用方便）。
- 可将AD/DA模块直接集成在单片机内，这样直接写入/读出寄存器就可进行AD/DA转换，单片机的IO口可直接复用为AD/DA的通道。

#### 运算放大器

运算放大器（简称“运放”）是具有很高放大倍数的放大电路单元。内部集成了差分放大器、电压放大器、功率放大器三级放大电路，是一个性能完备、功能强大的通用放大电路单元。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0ed8d4e98ed74aaebd29eac414ddf152.png)

输入端阻抗大，输出端有驱动能力，放大倍数很大

> 运算放大器可构成的电路有：电压比较器、反相放大器、同相放大器、电压跟随器、加法器、积分器、微分器等。
>
> ------
>
> 运算放大器电路的分析方法：虚短、虚断（负反馈条件下）

#### 运放电路

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3ac428b48eb847c999c49f01ce85d410.png)

- 电压比较器：OUT=（IN+ -IN-）*放大倍数
- 反向放大器：
  1. VIN>0;导致OUT为负无穷
  2. OUT将-接线柱电压拉至负无穷；OUT变为正无穷
  3. 循环往复，直至达到稳态，-接线柱处形成虚短,电压与+接线柱相等，为0，形成虚断，-接线柱处没有电流通过，输入电流为VIN/R1
  4. 输入电流只从R2处经过，形成压降；OUT=-VIN*R2/R1;R2/R1即为放大倍数
  5. 另：输入端阻抗比较大，对前期电路影响小；需要接入双电源，否则会饱和溢出，不能输出负电压；接入双电源，即两电源串联，中部接地，正极接+极，负极接-级

 ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/40c029b2b99a4e92915e21cb8cec7685.png)

- 同向放大器
  - <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112222716641.png" alt="image-20241112222716641" style="zoom:67%;" />
- 电压跟随器
  - 功放内部含有功率放大器，可提高驱动能力
  - 相当于同向放大器R1为无穷大

#### DA原理

T型电阻网络DA转换器：

![image-20241112223638133](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112223638133.png)

D7-D0:位权逐渐减半

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112223748986.png" alt="image-20241112223748986" style="zoom:50%;" />

PWM型DA转换器：

![image-20241112224321291](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112224321291.png)

输出电压：V = (PWM占空比)*VH

#### AD原理



逐次逼近型AD转换器：

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112234457799.png" alt="image-20241112234457799" style="zoom:67%;" />

依次二等分与实际电压比较，偏小则置1，偏大则置0，最终得出八位数字

#### 原理图

AD:

![image-20241112233449002](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112233449002.png)

DA:

![image-20241112234758508](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241112234758508.png)

#### AD/DA性能指标

性能指标：AD/DA数字量的精细程度，通常用位数表示。AD/DA**位数越高，分辨率就越高**。

转换速度：表示AD/DA的最大采样/建立频率，通常用转换频率或者转换时间来表示，对于采样/输出高速信号，应注意AD/DA的转换速度

AD/DA的通道数

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113001905050.png" alt="image-20241113001905050" style="zoom:67%;" />

#### XPT2046

XPT2046是4线制电阻式触摸屏控制器，内含12位分辨率25KHz转换速率逐步逼近型A/D转换器。

时序：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/830e1c6a590a42eb89dd58bba6023869.png)

> **一横CS**：低电平片选。
>  **DCLK**：**上升沿输入，下降沿输出。**
>  **DIN**：输入。
>  **DOUT**：输出。

#### 命令字

基本：0x8C，1000 1100

7：S**=1**，标志新的控制字节
6-4：通道选择位，
	XP:001;
	YP:101;
	VBAT:010;
	AUX:110
3：模式选择，**MODE=1，八位**分辨率；MODE=2十二位分辨率
2：输入方式选择位，**=1，单端输入**，=0差分输入；X-.Y-已接地，故选择单端输入
1-0：**00**

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/386b357171a64ecd9064710087ca5f57.png)
![image-20241113163331458](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113163331458.png)

#### 实践

```c
//XPT2046.c
#include <REGX52.H>

sbit XPT2046_CS=P3^5;
sbit XPT2046_DIN=P3^4;
sbit XPT2046_DOUT=P3^7;
sbit XPT2046_DCLK=P3^6;

unsigned int XPT2046_ReadAD(unsigned char Command){
	unsigned char i;
	unsigned int ADValue=0;
	
	XPT2046_DCLK=0;
	XPT2046_CS=0;
	
	for(i=0;i<8;i++){
		XPT2046_DIN=Command&(0x80>>i);
		XPT2046_DCLK=1;//上升沿输入
		XPT2046_DCLK=0;
	}
	for(i=0;i<16;i++){
		XPT2046_DCLK=1;
		XPT2046_DCLK=0;//下降沿输出
		if(XPT2046_DOUT){ADValue|=(0x8000>>i);}//输出16位
	}
	XPT2046_CS=1;

	return ADValue>>8;//输出16位而仅使用8位

}
```

```c
//XPT2046.h
#ifndef __XPT2046_H__
#define __XPT2046_H__

#define XPT2046_XP 0x9C //0x8C//滑变
#define XPT2046_YP 0xDC		  //热敏电阻
#define XPT2046_VBAT 0xAC	  //光敏电阻
#define XPT2046_AUX 0xEC

unsigned char XPT2046_ReadAD(unsigned char Command);

#endif

```

### 红外遥控

利用红外光进行通信的设备，由红外LED将调制后的信号发出，由专门的红外接收头解调输出。

> 通信方式：单工，异步
>  红外LED波长：940nm
>  通信协议标准：NEC标准

####  基本发送与接收

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f5c4aaa416644078904aefcb55976956.png)

> **空闲状态**：红外LED不亮，输出头输出高电平。
>  **发送低电平**：红外LED以38KHz频率闪烁发光，接收头输出低电平。
>  **发送高电平**：红外LED不亮，输出头输出高电平。

#### NEC编码

![image-20241113170000893](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113170000893.png)

9ms低电平+4.5ms高电平=Start
560us低电平+560us高电平=0
560us低电平+1690us高电平=1
9ms低电平+2.25ms高电平=Repeat

Data格式：地址码（00000000）+地址码取反（11111111）+命令+命令取反
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113175231251.png" alt="image-20241113175231251" style="zoom:50%;" />

红外遥控器各键位对应地址

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113175319793.png" alt="image-20241113175319793" style="zoom:67%;" />

#### 外部中断

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/96247a68224e4ec48e7b07c9cea00b68.png)

STC89C52由4个外部中断，传统的只有2个外部中断。
 外部中断的触发方式分别为：**下降沿触发、低电平触发**。

#### 中断号

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9e4e994968ac4b6f99a3ad4f94b41f8a.png)

外部中断0和外部中断1分别对应interrupt 0和interrupt 2

#### 外部中断寄存器

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113180753054.png" alt="image-20241113180753054" style="zoom:67%;" />

T0，T1：定时器0，定时器1的中断

RX，TX：串口中断

横杠INT0，横杠INT1：外部中断0，P3_2，外部中断1，P3_3

EX0/EX1：IE0/IE1的使能

EA：所有中断的使能

IE0/IE1:中断标志位

PX0/PX1：设置中断优先级，置1即为较优先，置0即为较不优先

TCON中IT0/IT1：控制低电平触发（0）还是下降沿触发（1）

#### 原理图

![请添加图片描述](https://i-blog.csdnimg.cn/direct/52394cffe9344736ac60b7fa6215f2f1.png)![image-20241113214341359](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241113214341359.png)

#### 实例

```c
//main.c
#include <REGX52.H>
#include "Delay.h"
#include "Key.h"
#include "Nixie.h"
#include "Motor.h"
#include "IR.h"

unsigned char Command,Speed;

void main()
{
	Motor_Init();
	IR_Init();
	while(1)
	{
		if(IR_GetDataFlag())	//如果收到数据帧
		{
			Command=IR_GetCommand();		//获取遥控器命令码
			
			if(Command==IR_0){Speed=0;}		//根据遥控器命令码设置速度
			if(Command==IR_1){Speed=1;}
			if(Command==IR_2){Speed=2;}
			if(Command==IR_3){Speed=3;}
			
			if(Speed==0){Motor_SetSpeed(0);}	//速度输出
			if(Speed==1){Motor_SetSpeed(50);}
			if(Speed==2){Motor_SetSpeed(75);}
			if(Speed==3){Motor_SetSpeed(100);}
		}
		Nixie(1,Speed);						//数码管显示速度
	}
}
```

```c
//Timer1.c
#include <REGX52.H>

/**
  * @brief  定时器1初始化，100us@12.000MHz
  * @param  无
  * @retval 无
  */
void Timer1_Init(void)
{
	TMOD &= 0x0F;		//设置定时器模式
	TMOD |= 0x10;		//设置定时器模式
	TL1 = 0x9C;		//设置定时初值
	TH1 = 0xFF;		//设置定时初值
	TF1 = 0;		//清除TF1标志
	TR1 = 1;		//定时器1开始计时
	ET1=1;
	EA=1;
	PT1=0;
}

/*定时器中断函数模板
void Timer1_Routine() interrupt 3
{
	static unsigned int T1Count;
	TL1 = 0x9C;		//设置定时初值
	TH1 = 0xFF;		//设置定时初值
	T1Count++;
	if(T1Count>=1000)
	{
		T1Count=0;
		
	}
}
*/
```

```c
//Timer0.c
#include <REGX52.H>

/**
  * @brief  定时器0初始化
  * @param  无
  * @retval 无
  */
void Timer0_Init(void)
{
	TMOD &= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式
	TL0 = 0;		//设置定时初值
	TH0 = 0;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 0;		//定时器0不计时
}

/**
  * @brief  定时器0设置计数器值
  * @param  Value，要设置的计数器值，范围：0~65535
  * @retval 无
  */
void Timer0_SetCounter(unsigned int Value)
{
	TH0=Value/256;
	TL0=Value%256;
}

/**
  * @brief  定时器0获取计数器值
  * @param  无
  * @retval 计数器值，范围：0~65535
  */
unsigned int Timer0_GetCounter(void)
{
	return (TH0<<8)|TL0;
}

/**
  * @brief  定时器0启动停止控制
  * @param  Flag 启动停止标志，1为启动，0为停止
  * @retval 无
  */
void Timer0_Run(unsigned char Flag)
{
	TR0=Flag;
}
```

```c
//Motor.c
#include <REGX52.H>
#include "Timer1.h"

//引脚定义
sbit Motor=P1^0;

unsigned char Counter,Compare;

/**
  * @brief  电机初始化
  * @param  无
  * @retval 无
  */
void Motor_Init(void)
{
	Timer1_Init();
}

/**
  * @brief  电机设置速度
  * @param  Speed 要设置的速度，范围0~100
  * @retval 无
  */
void Motor_SetSpeed(unsigned char Speed)
{
	Compare=Speed;
}

//定时器1中断函数
void Timer1_Routine() interrupt 3
{
	TL1 = 0x9C;		//设置定时初值
	TH1 = 0xFF;		//设置定时初值
	Counter++;
	Counter%=100;	//计数值变化范围限制在0~99
	if(Counter<Compare)	//计数值小于比较值
	{
		Motor=1;		//输出1
	}
	else				//计数值大于比较值
	{
		Motor=0;		//输出0
	}
}
```

```c
//Init0.c
#include <REGX52.H>

/**
  * @brief  外部中断0初始化
  * @param  无
  * @retval 无
  */
void Int0_Init(void)
{
	IT0=1;//下降沿触发
	IE0=0;/外部中断0中断标志位置0
	EX0=1;//外部中断0使能
	EA=1;//使能
	PX0=1;//设置为高优先级
}

/*外部中断0中断函数模板
void Int0_Routine(void) interrupt 0
{
	
}
*/
```

```c
//IR.c
#include <REGX52.H>
#include "Timer0.h"
#include "Int0.h"

unsigned int IR_Time;
unsigned char IR_State;

unsigned char IR_Data[4];
unsigned char IR_pData;

unsigned char IR_DataFlag;
unsigned char IR_RepeatFlag;
unsigned char IR_Address;
unsigned char IR_Command;

/**
  * @brief  红外遥控初始化
  * @param  无
  * @retval 无
  */
void IR_Init(void)
{
	Timer0_Init();
	Int0_Init();
}

/**
  * @brief  红外遥控获取收到数据帧标志位
  * @param  无
  * @retval 是否收到数据帧，1为收到，0为未收到
  */
unsigned char IR_GetDataFlag(void)
{
	if(IR_DataFlag)
	{
		IR_DataFlag=0;
		return 1;
	}
	return 0;
}

/**
  * @brief  红外遥控获取收到连发帧标志位
  * @param  无
  * @retval 是否收到连发帧，1为收到，0为未收到
  */
unsigned char IR_GetRepeatFlag(void)
{
	if(IR_RepeatFlag)
	{
		IR_RepeatFlag=0;
		return 1;
	}
	return 0;
}

/**
  * @brief  红外遥控获取收到的地址数据
  * @param  无
  * @retval 收到的地址数据
  */
unsigned char IR_GetAddress(void)
{
	return IR_Address;
}

/**
  * @brief  红外遥控获取收到的命令数据
  * @param  无
  * @retval 收到的命令数据
  */
unsigned char IR_GetCommand(void)
{
	return IR_Command;
}

//外部中断0中断函数，下降沿触发执行
void Int0_Routine(void) interrupt 0
{
	if(IR_State==0)				//状态0，空闲状态
	{
		Timer0_SetCounter(0);	//定时计数器清0
		Timer0_Run(1);			//定时器启动
		IR_State=1;				//置状态为1
	}
	else if(IR_State==1)		//状态1，等待Start信号或Repeat信号
	{
		IR_Time=Timer0_GetCounter();	//获取上一次中断到此次中断的时间
		Timer0_SetCounter(0);	//定时计数器清0
		//如果计时为13.5ms，则接收到了Start信号（判定值在12MHz晶振下为13500，在11.0592MHz晶振下为12442）
		if(IR_Time>12442-500 && IR_Time<12442+500)
		{
			IR_State=2;			//置状态为2
		}
		//如果计时为11.25ms，则接收到了Repeat信号（判定值在12MHz晶振下为11250，在11.0592MHz晶振下为10368）
		else if(IR_Time>10368-500 && IR_Time<10368+500)
		{
			IR_RepeatFlag=1;	//置收到连发帧标志位为1
			Timer0_Run(0);		//定时器停止
			IR_State=0;			//置状态为0
		}
		else					//接收出错
		{
			IR_State=1;			//置状态为1
		}
	}
	else if(IR_State==2)		//状态2，接收数据
	{
		IR_Time=Timer0_GetCounter();	//获取上一次中断到此次中断的时间
		Timer0_SetCounter(0);	//定时计数器清0
		//如果计时为1120us，则接收到了数据0（判定值在12MHz晶振下为1120，在11.0592MHz晶振下为1032）
		if(IR_Time>1032-500 && IR_Time<1032+500)
		{
			IR_Data[IR_pData/8]&=~(0x01<<(IR_pData%8));	//数据对应位清0
			IR_pData++;			//数据位置指针自增
		}
		//如果计时为2250us，则接收到了数据1（判定值在12MHz晶振下为2250，在11.0592MHz晶振下为2074）
		else if(IR_Time>2074-500 && IR_Time<2074+500)
		{
			IR_Data[IR_pData/8]|=(0x01<<(IR_pData%8));	//数据对应位置1
			IR_pData++;			//数据位置指针自增
		}
		else					//接收出错
		{
			IR_pData=0;			//数据位置指针清0
			IR_State=1;			//置状态为1
		}
		if(IR_pData>=32)		//如果接收到了32位数据
		{
			IR_pData=0;			//数据位置指针清0
			if((IR_Data[0]==~IR_Data[1]) && (IR_Data[2]==~IR_Data[3]))	//数据验证
			{
				IR_Address=IR_Data[0];	//转存数据
				IR_Command=IR_Data[2];
				IR_DataFlag=1;	//置收到连发帧标志位为1
			}
			Timer0_Run(0);		//定时器停止
			IR_State=0;			//置状态为0
		}
	}
}
```

```c
//IR.h
#ifndef __IR_H__
#define __IR_H__

#define IR_POWER		0x45
#define IR_MODE			0x46
#define IR_MUTE			0x47
#define IR_START_STOP	0x44
#define IR_PREVIOUS		0x40
#define IR_NEXT			0x43
#define IR_EQ			0x07
#define IR_VOL_MINUS	0x15
#define IR_VOL_ADD		0x09
#define IR_0			0x16
#define IR_RPT			0x19
#define IR_USD			0x0D
#define IR_1			0x0C
#define IR_2			0x18
#define IR_3			0x5E
#define IR_4			0x08
#define IR_5			0x1C
#define IR_6			0x5A
#define IR_7			0x42
#define IR_8			0x52
#define IR_9			0x4A

void IR_Init(void);
unsigned char IR_GetDataFlag(void);
unsigned char IR_GetRepeatFlag(void);
unsigned char IR_GetAddress(void);
unsigned char IR_GetCommand(void);

#endif
```

