## 逻辑大学 

### 前言

在我们日常生活中，无论说话、做事，甚至只是学习、认识某种事物，都离不开一套方法，做事的方法、认识的方法。这种思维的实践的方法以及总结这种方法的理论，就是逻辑，就是逻辑的学问。逻辑和做事的顺序、对事物的性质判别、乃至认识事物的角度都有关系。

然而，因为家庭教育受到整个社会的资产阶级思想的腐蚀，大多对于孩子的培养是以经济和升学为主，学校里、家庭里的教育都对逻辑的培养非常疏忽，乃至于让年轻人欠缺逻辑思维，说话、认识、做事非常跳脱、非常感性却不自知。

让每一个人都能够懂得逻辑，不会因为思维的跳脱与感性而引发错误的思考和思考结果，这是很好的事情。但也只有静下心来体会和分析生活中的每一处小事情，才能锻炼逻辑思维。实践是认识的来源、目的，以及唯一的检验标准，所以使用一些真实案例来辅助认识，可以更准确客观地让人在头脑中留下正确的知识。

在逐一认识各种逻辑谬误与各种逻辑之前，感兴趣的读者可以先行记录以下辩证法的基本范畴，这在之后的分析谬误中可以用到。辩证法遵循的是辩证逻辑，其核心是对立统一。围绕这个核心，辩证法衍生出如下二十三个基本范畴：量变质变、肯定否定、内因外因、普遍特殊、相对绝对、原因结果、偶然必然、可能现实、形式内容、现象本质、根据条件、有限无限、主观客观、理性感性、共性个性、自由限制、两极中介、链条环节、动机效果、个别一般、局部全局、主流支流、正面反面。

### 一、完全不通的逻辑断点——谬误

谬误，指不依据逻辑的议论，尤其指论证中不符合逻辑的推论，是生活中人人都会不知不觉犯下的逻辑错误。逻辑是主观符合客观，从而使事物运动过程通顺起来，使人的认识符合客观世界的方法，谬误就是逻辑不通导致的结果，会使人的认识、表达与实践出现差错。

需要事先说明的是，何为“正确”，何为“错误”呢？评判正确错误，并不依靠个人情感，也不依靠民主投票，而是依靠实践后得来的客观事物反映。所以评判逻辑的正确与否，一个非常重要的前提便是，需要足够大量的亲身实践，以获得最基础最根本的客观认识。

谬误分为很多种，而依据辩证法一分为二，可分为非形式逻辑谬误与形式逻辑谬误两大类，其中最简单而浅显的谬误，也是最令人惊讶、最过分的谬误，是属于非形式逻辑谬误的六个“诉诸”谬误。诉诸无知、诉诸类比、诉诸公众、诉诸权威、诉诸传统、诉诸主观情感。这六个谬误，错误的严重程度甚至到违反了形式逻辑的运行方式，是悬在空中的低级错误。

**诉诸无知**，含义为：“**因为一件事物未被证明或无法证明是错误的，即断定该事物正确。**”人并未知道这件事物是否错误，便要断定该事物正确，这种行为甚至会让其他人觉得非常愚蠢。比如，在最初生产出火药时，如果在尚未验证火药是否会炸死人时，有人便要断定火药绝对不会炸死人，就连日常里经常外出玩耍的小孩也要嘲笑这人，愚蠢、武断而蒙塞。宗教与阴谋论便是如此，在无法证明上帝是否存在时，他们便要坚信上帝一定存在；在无法证明某件事情的具体始作俑者时，他们便要一口咬定是某个可能性。还有目前最常见的一个观点：“宇宙这么大，肯定存在外星人。”没有任何确凿证明外星人存在的证据，仅仅以没有强逻辑关联的宇宙规模来论证。**这种逻辑谬误最根本的是，对该事物下的定论没有经过任何实践的检验，甚至连间接的检验也没有**，好比未经查看便把手伸向池塘里的一个罐子，里面有鱼或者有毒虫毒蛇一概不知，却偏要认为这罐子非常安全。**诉诸无知的性质，属于彻彻底底的主观唯心，仅以自身的想法为依据，不理会实际客观情况，是非常危险而低级的逻辑谬误。**
“宇宙这么大，肯定存在外星人。”

**诉诸类比**，含义为：“**将论证范畴涉及各自个性的两个事物统一起来，忽略其个性的影响，只用共性将整个论证范畴涵盖。**”比如，将切菜与砍树拉拢在一起，说，“因为切菜不需要多少力气，所以砍树也不需要多少力气。”在这一个例子中，论证者错误地只关注了切菜与砍树中为数不多的共性，而忽略了它们的个性，仅仅因为同样是切割动作，便要忽略菜本身的脆软和树本身的坚硬，将两者类比起来。又比如，“教大学生学高数非常简单，所以教小学生高数也一样会很简单。”这里则是忽视了大学生与小学生的区别，大学生的知识积累与理解能力比小学生深厚许多，不能一概而论。再有一个例子，有人说，“我在办公室，不也跟你在流水线一样嘛，都是锻炼。”这种人则是只看到了两者的共性，都要花费心思和体力，但没有看到两者的区别，办公室与流水线的精力体力消耗程度是不一样的，从而其辛劳程度也有质的区别。**诉诸类比的逻辑性质，属于典型的形而上学，仅仅抓住事物的共性进行论证，不理会其个性的一面，是非常典型的逻辑谬误。**

诉诸公众，含义为：“**以实践该事物的人数而不是事物本身的性质及客观影响来评判。**”敏锐的读者或许可以看出，这一手段并非论证作用，而只发挥说服作用。真理与认识是否符合实践后事物客观反应有关，而与支持人数没有任何逻辑关联。比如，因为许多人在吸烟，便认为吸烟不会危害健康；比如，因为国内民族主义被大部分人支持，便认为日本应当经历大屠杀；再比如，因为许多人横穿马路而不看交通灯，便认为中国式过马路可取。**这种逻辑谬误利用的是从众效应，仿佛只要做的人多了便成为正确的一方似的。诉诸公众，是仅仅依靠感性进行论证的逻辑谬误，各种论证环节连理性也谈不上了。**
“因为许多人在吸烟，所以吸烟不会危害健康”

**诉诸权威**，含义为：“**仅凭借或者主要凭借一个权威组织或权威人物的观点来论证自己的观点。**”表面上看，这与学生上学时写文章没有太大区别，引用名人名言来论述某件事情，或形象直白阐述某个道理。然而诉诸权威的一大谬误就在于，它用权威言论取代有力而客观的论述，将权威放在主要部分主要方面，使权威言论直接影响到整个论述的性质。论述者忽略了权威言论的非绝对正确性，忽视了权威人士或权威组织的犯错可能性，从而无条件地假设权威言论的合理性，发生了诉诸权威谬误。比如，某国总统支持法西斯主义，法西斯主义便是正确的。然而**值得注意的是，因为权威组织或权威人物的观点不一定错误，所以不可以在论述者诉诸权威时直接否定整个观点。诉诸权威是一个具有错误风险的谬误。**

**诉诸传统**，含义为：“**仅因为过去的人们采用了这种做法，便认为这种做法正确。**”表面上看，这种逻辑遵循了实践第一性、实践决定认识的唯物主义认识论，然而它是**形而上学的唯物主义，忽视了从过往到现在的世界发展历史中，事物的运动发展是不间断的，从而过去的认识、过去的做法不一定适合于当下，当下的认识与做法也不一定适合于未来。**比如“以前的人们一直以来都要在开电视前摇晃天线，我们现在应该继续这么做。”

**诉诸主观情感**，含义为：“**动机合情的行为是恰当的，因而正确。**”这种谬误通常由主观情感，即由感性引导，利用主观情感论证客观事物的正确性，甚至利用合乎主观情感来论证事物绝对正确。比如构建文化霸权理论的错误前提“只要歌颂祖国便是正确的”；比如换位思考，“如果你是愤怒的受害者的家人，你还会认为动用私刑是错误的吗？”；比如假设换位，“如果你也这么穷，你也一定会造假公章骗医疗费的，所以他现在这么做没有问题。”这些判断对错的标准在事实上都由人的主观情感决定了，无论是处在该位置的人，还是进行共情的旁观者。**诉诸主观情感给人一种感觉，论述者幼稚而蛮横，尚未开化，只是从自己感觉出发，想要以自我为中心，或者以某个人为中心来评判一切事物，这是一种非常典型的主观逻辑，是错误的。同时，由于小资的感性崇拜，诉诸主观情感是最常见的逻辑谬误。**
“只要爱国就是正确的”——战马行动低级红事件

在以上六种最低级的逻辑谬误之后，是容易使人不知不觉间犯下的六种逻辑谬误。

**循环论证**，含义为：“**用假设去证明假设的逻辑谬误。**”人们很容易不知不觉就犯下这种谬误，或许是由于他们急于证明自己的假设是对的，或者他们走投无路，只好绕回来，又或者只是对自己的思维认识不深刻，被自己的思路绕晕了。比如在古典经济学时期，为了解释商品价值的衡量方法与给出商品价值的衡量尺度，经济学家们不得不在劳动价值论的基础上，将劳动视为商品价值的衡量标准。然而在他们看来，劳动本身也是作为商品参与到商品交易之中的，而劳动这个商品的商品价值，便也只能用劳动自身去衡量，从而无法确定切实的价值量。劳动本身的价值量都无法确定，那其他以劳动为价值衡量标准的商品就更加无法确定价值量了。**循环论证，就是假设的自指，以自身证明自身，无法走出这个循环，必须寻找事物的联系以打破这个循环。**值得一提的是，由于人们对循环论证的发生过程不敏感，诡辩者通常会通过绕一大圈的方式，利用循环论证来论述自己的观点，企图蒙混过关，忽悠对方。

**滑坡谬误**，含义为：“**将可能性与必然性等同，将某些相关因素放大。**”这种谬误的发生有时伴随钻牛角尖的极端思想，或破罐子破摔的自暴自弃态度。比如一个例子，有个痛恨厌恶同性恋的人叫嚣，如果你们允许哪个男人同男人结婚，那么你们终究也会允许人同猪、狗、狼甚至桌子、椅子结婚。这个人企图以荒唐魔幻的结果来放大同性恋通婚的“危害”，以此支持自己反对同性恋通婚的观点。然而众所周知，即使同性恋结婚，也只局限于人类的同性恋，而绝不会将结婚对象拓展到非人类。只因为猪狗狼与人类同是动物，甚至桌子椅子与人同样是地球上存在的事物，便要兀自凭空将这些也说成是同性恋要结婚的对象，实在是无稽之谈。这也是一种极端思想的体现，一种行为令某人自己不顺眼，便要通过事物之间的共性，把范畴扩展到包括所有令他不顺眼的其他事情上。
“同性恋者会和桌子椅子结婚？”

**以偏概全**，含义为：“**认为个体中包含的某种性质，就是包含该个体的群体具有的普遍性质。”这是典型的将个性当做共性的逻辑错误，**比如“小明这道题做对了，那么他整张卷子就都能做对，”又比如“这个坏人是这个国家的，则这个国家的人都是坏人。”

**区群谬误**，含义为：“**以全概偏，认为群体普遍存在某种性质，则任何个体必定存在该种性质。**”比如“猫有四条腿，则每一只猫都必定有四条腿。”“这个班级期末考试成绩很好，则班级里的每个人都考得很好。”这是一种典型的**将特殊性与普遍性割裂开的逻辑错误**。

**后此谬误**，含义为：“**事后归因，仅仅因为甲事件先于乙事件发生，就断定甲是乙的发生原因。**”比如，因为商业发展前与发展时有工资与物价上涨的现象，人们便认为，提高工资与价格可以解决经济大萧条。**这种逻辑谬误简单粗暴而表面地构建了事物之间的联系，忽视了事物之间联系的客观性，主观捏造的事物联系并不能对现实产生任何影响。**

**不相干谬误**，含义为：“**扭曲论证对象，转移讨论焦点，以一个相似于原事物的新事物代替原事物并进行论证。**”这种谬误**又叫偷换概念、逃避话题。**比如“你喜欢吃调味牛肉干，则你必定喜欢吃鲜牛肉，你喜欢吃鲜牛肉，则也必定喜欢喝牛奶。”这种看似理所当然的谬误同样只看见了事物的共性而忽略了个性，只注重了它们的共同点，而忽视了其区别。这种逻辑谬误的经典形式便是著名的“稻草人谬误”，比如，有一个人认为，应当要对那些屡教不改的罪犯实施劳动改造，当即有另一人跳出来指责，你要让罪犯连续劳作三天还不给休息，这是违反人道的！后者所攻击的观点“不给罪犯休息”是前者从未提及的，也无法从前者的观点中推导出来，只是后者树立的稻草人，与前者的真正论点毫无关系。

非形式逻辑谬误是人们容易犯下的低级逻辑错误，下意识地多加思考，或许可以避免，形式逻辑谬误则是一种并非下意识思考便一定能避免的逻辑错误，因为它涉及我们自发性的思维错误，与原生的思维方式有很大关系。

**否定前件谬误**：如果铁会氧化，那么不是铁做的东西就不会氧化。这种谬误或来自对客观世界的认知缺乏，或来自对直言三段式的误用。直言三段式的使用不具备反面成立的性质，比如，如果铁会氧化，那么一个东西是铁做的，它就会氧化。

**肯定后件谬误**：如果铁会氧化，铜也会氧化，那么铁就是铜。这种谬误与否定前件谬误对立统一，同样是误用直言三段式的谬误，只不过是另一种形态。

**假两难谬误**：如果一个东西不是铁做的，那么它必定是铜做的。这种谬误忽略了所有中立的情况，是选言三段论的误用。选言三段论的使用不具备忽略中立项的条件，比如，如果一个东西不是铁做的，也不是除了铜以外的其他东西做的，那么它必定是铜做的。

以上就是所有逻辑谬误种类。虽然大家看着会感觉非常荒唐，然而这样的谬误仍然普遍存在于我们的生活之中，特别是在与人争辩的过程中无意犯下。这需要我们注意自己的观点，三思后发言，多思考，多整理自己的思路，最基本的是要将自发的朴素逻辑，变作辩证逻辑。 作者：云舟文化 https://www.bilibili.com/read/cv39532132/ 出处：bilibili

## 硬件

### 蜂鸣器

蜂鸣器按驱动方式可分为有源蜂鸣器和无源蜂鸣器
有源蜂鸣器:内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定
无源蜂鸣器:内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音

有源蜂鸣器只需要给单一的高低电平就可以了，无源蜂鸣器要给脉冲

不能让无源蜂鸣器始终通电

### 存储器

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241017164631763.png" alt="image-20241017164631763" style="zoom:50%;" />

RAM:掉电丢失，速度快

​	SRAM:锁存器（D触发器）。速度最快，容量少，成本高，cpu高速缓存，变量存储于此

​	DRAM:电容。容易漏电，搭配扫描电路，用以充电，成本较低，容量更多，内存条，

ROM:掉电不丢失，速度慢

​	Mask ROM：最早期，只能读，不能写

​	PROM：只可写一次

​	EPROM：紫外线照射三十分钟擦除

​	E2PROM/EEPROM：单片机，如24c02

​	Flash：非常广泛

​	硬盘，光盘，软盘：

### E2PROM

AT24c02：掉电不丢失，I2C总线，256字节

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241017170615350.png" alt="image-20241017170615350" style="zoom:50%;" />

## C

### const

**(4) const 可以节省空间，避免不必要的内存分配。 例如：**

```
#define NUM 3.14159 //常量宏
const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ......
double i = Num; //此时为Pi分配内存，以后不再分配！
double I= NUM; //编译期间进行宏替换，分配内存
double j = Num; //没有内存分配
double J = NUM; //再进行宏替换，又一次分配内存！
```

const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 # define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 # define 定义的常量在内存中有若干个拷贝。

### 存储类

#### auto

所有局部变量默认的存储类。

定义在函数中的变量默认为 auto 存储类，这意味着它们在函数开始时被创建，在函数结束时被销毁。

#### register

用于定义存储在**寄存器**中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于**寄存器的大小（通常是一个字**），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

register 存储类定义存储在寄存器，所以变量的**访问速度更快**，但是它**不能直接取地址**，因为它不是存储在 RAM 中的。在需要**频繁访问的变量上使用** register 存储类可以提高程序的运行速度。

寄存器只用于需要快速访问的变量，比**如计数器**。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

#### static

会使变量的作用域限制在声明它的文件内，使成为全局变量。全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

静态变量在程序中**只被初始化一次**，即使函数被调用多次，该**变量的值也不会重置**。

#### extern

**定义与声明**：全局变量或函数只能定义一次，但可以多次声明。如果一个文件中定义了全局变量或函数，那么在其他文件中应该使用`extern`来声明它，而不是再次定义。

**链接器**：使用`extern`声明的全局变量或函数需要链接器来解析它们的定义。如果链接器找不到定义，程序将无法正确运行。

**头文件**：通常，我们会在一个头文件中使用`extern`声明全局变量或函数，然后在需要使用这些变量或函数的文件中包含这个头文件。

**初始化**：全局变量的初始化应该在定义它们的文件中进行，而不是在声明中进行。

### 逻辑运算符

| 运算符 | 描述                                                         | 实例                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| &      | 对两个操作数的每一位执行逻辑与操作，如果两个相应的位都为 1，则结果为 1，否则为 0。按位与操作，按二进制位进行"与"运算。运算规则： `0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 对两个操作数的每一位执行逻辑或操作，如果两个相应的位都为 0，则结果为 0，否则为 1。按位或运算符，按二进制位进行"或"运算。运算规则： `0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 对两个操作数的每一位执行逻辑异或操作，如果两个相应的位值相同，则结果为 0，否则为 1。异或运算符，按二进制位进行"异或"运算。运算规则： `0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 对操作数的每一位执行逻辑取反操作，即将每一位的 0 变为 1，1 变为 0。取反运算符，按二进制位进行"取反"运算。运算规则： `~1=-2;    ~0=-1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 将操作数的所有位向左移动指定的位数。左移 n 位相当于乘以 2 的 n 次方。二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 将操作数的所有位向右移动指定的位数。右移n位相当于除以 2 的 n 次方。二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。 | A >> 2 将得到 15，即为 0000 1111                             |

#### ？ ：

| ? :  | 条件表达式 | 如果条件为真 ? 则值为 X : 否则值为 Y |
| ---- | ---------- | ------------------------------------ |

例： b = (a == 10) ? 20: 30;

### do while

不像 **for** 和 **while** 循环，它们是在循环头部测试循环条件。在 C 语言中，**do...while** 循环是在循环的尾部检查它的条件。

**do...while** 循环与 while 循环类似，但是 do...while 循环会确保至少执行一次循环。

### break

C 语言中 **break** 语句有以下两种用法：

1. 当 **break** 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。
2. 它可用于终止 **switch** 语句中的一个 case。

如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。

### continue

C 语言中的 **continue** 语句有点像 **break** 语句。但它不是强制终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。

对于 **for** 循环，**continue** 语句执行后自增语句仍然会执行。对于 **while** 和 **do...while** 循环，**continue** 语句重新执行条件判断语句。

### goto（劳资不用）

C 语言中的 **goto** 语句允许把控制无条件转移到同一函数内的被标记的语句。

**注意：**在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。

### 无限循环

如果条件永远不为假，则循环将变成无限循环。**for** 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。

#### 实例

```
#include <stdio.h>
 
int main ()
{
   for( ; ; )
   {
      printf("该循环会永远执行下去！\n");
   }
   return 0;
}
```

一个无限循环。



### 内部函数

如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 **static**

### 外部函数

如果在定义函数时，在函数的首部的**最左端加关键字 extern**，则此函数是外部函数，可供其它文件调用。

C 语言规定，如果在定义函数时省略 extern，则**默认为外部函数**。

在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数。

**多次声明，一次定义**

### 函数参数

#### 传值调用

向函数传递参数的**传值调用**方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。

默认情况下，C 语言使用*传值调用*方法来传递参数。一般来说，这意味着函数内的代码不会改变用于调用函数的实际参数。

#### **传值调用**

通过引用传递方式，**形参为指向实参地址的指针**，当对形参的指向操作时，就相当于**对实参本身进行**的操作。

传递指针可以让**多个函数访问指针所引用的对象，而不用把对象声明为全局可访问。**

### 局部变量和全局变量

在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。

**全局变量与局部变量在内存中的区别**：

- 全局变量保存在内存的全局存储区中，占用静态的存储单元；
- 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。
- 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化

### 数组

- 存储一个**固定大小**的**相同类型元素**的**顺序**集合。


- 数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。


- 数组的声明并不是声明一个个单独的变量，而是**声明一个数组变量**，比如 runoob，然后使用 runoob[0]、runoob[1]、...、runoob[99] 来代表一个个单独的变量。


- 所有的数组都是由**连续的内存位置**组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

- 可以使用 **sizeof** 运算符来获取数组的长度

- 如果省略掉数组的大小，数组的大小则为初始化时元素的个数。

  

  数组名表示数组的地址，即数组首元素的地址。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。

  数组名本身是一个常量指针，意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方。

  可以使用&运算符来获取数组的地址。

  ```
  int *ptr = &myArray[0]; // 或者直接写作 int *ptr = myArray;
  ```

#### 传递数组给函数

1. void myFunction(int *param);
2. void myFunction(int param[10]);
3. void myFunction(int param[]);

#### 从函数返回数组

int * myFunction()

#### 指向数组的指针

在下面的声明中：

```
double balance[50];
```

**balance** 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：

```
double *p;
double balance[10];

p = balance;
```

使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

一旦您把第一个元素的地址存储在 p 中，您就可以使用* p、* (p+1)、* (p+2) 等来访问数组元素。

#### 静态数组与动态数组

- 静态数组：编译时分配内存，大小固定。内存分配在栈区，通常使用方括号 []  来定义。访问速度较快。自动管理。
- 动态数组：运行时手动分配内存，大小可变。并存储在堆上。使用 `malloc`、`calloc` 等函数来申请内存，并使用 `free` 函数来释放内存。大小在运行时可以根据需要进行调整。可以使用 `realloc` 函数来重新分配内存，并改变数组的大小。

静态数组的生命周期与作用域相关，而动态数组的生命周期由程序员控制。

在使用动态数组时，需要注意合理地分配和释放内存，以避免内存泄漏和访问无效内存的问题。

动态数组的声明、内存分配和释放实例：

```
int size = 5;
int *dynamicArray = (int *)malloc(size * sizeof(int)); // 动态数组内存分配
// 使用动态数组
free(dynamicArray); // 动态数组内存释放
```

检查是否成功分配内存：

```
if (dynamicArray == NULL) {
   printf("Memory allocation failed.**\n**");
   return 1;
}

```

### enum枚举

*一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读。*

```
enum　枚举名　{枚举元素1,枚举元素2,……};
```

如：一星期有 7 天，如果不用枚举，我们需要使用 # define 来为每个整数定义一个别名：

```
#define MON  1 
#define TUE  2 
#define WED  3 
#define THU  4 
#define FRI  5 
#define SAT  6 
#define SUN  7
```

这个看起来代码量就比较多，接下来我们看看使用枚举的方式：

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

#### 枚举变量

**1、先定义枚举类型，再定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
```

**2、定义枚举类型的同时定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

**3、省略枚举名称，直接定义枚举变量**

```
enum
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的

实例：

```
#include <stdio.h>
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
int main()
{
    // 遍历枚举元素，需要连续，否则无法遍历
    for (day = MON; day <= SUN; day++) {
        printf("枚举元素：%d \n", day);
    }
}
```

#### 将整数转换为枚举

```
enum day
{
    saturday,
    sunday,
    monday,
    tuesday,
    wednesday,
    thursday,
        friday
} workday;
 
int a = 1;
enum day weekend;
weekend = ( enum day ) a;  //类型转换
//weekend = a; //错误
printf("weekend:%d",weekend);
```



### srand()和rand()

`srand()` 是 C 标准库中的一个函数，用于设置随机数生成器的种子值。当你调用 `srand( (unsigned)time( NULL ) );` 这行代码时，它做了以下几件事情：

1. `time(NULL)`：调用 `time` 函数获取当前时间。`time` 函数返回从1970年1月1日（UTC）开始到当前时刻的秒数。`NULL` 参数表示不指定时区。
2. `(unsigned)time( NULL )`：将 `time` 函数返回的值转换为无符号整型。这个值通常是一个较大的数字，因为它是基于时间的，每次调用都可能不同。
3. `srand()`：接受一个无符号整型参数，并用它来初始化随机数生成器的内部状态。这个状态决定了后续 `rand()` 函数调用生成的随机数序列。

通过使用 `srand( (unsigned)time( NULL ) );`，每次程序运行时，由于时间的不同，`rand()` 函数都会生成一个不同的随机数序列。这样做的目的是确保每次程序运行时都能得到不同的随机数，这对于某些需要随机性的程序（如游戏、模拟、测试等）是有用的。

请注意，由于 `time` 函数返回的是秒级别的时间，如果程序在短时间内多次调用 `srand()`，可能会得到相同的种子值，从而导致 `rand()` 生成相同的随机数序列。在这种情况下，可能需要使用更精细的时间函数（如 `clock` 函数或特定平台的高精度时间函数）来获取更好的随机性。

### sizeof() 和 strlen()区别

主要区别在于：

- `sizeof()` 是一个运算符，而 `strlen()` 是一个函数。
- `sizeof()` 计算的是变量或类型所占用的内存字节数，而 `strlen()` 计算的是字符串中字符的个数。
- `sizeof()` 可以用于任何类型的数据，而 `strlen()` 只能用于以空字符 '\0' 结尾的字符串。
- sizeof() 计算字符串的长度，包含末尾的 '\0'，strlen() 计算字符串的长度，不包含字符串末尾的 '\0'。



sizeof() 的使用方法如下：

```
sizeof(type)
sizeof(variable)
```

获取数组长度：	

```
length = sizeof(numbers) / sizeof(numbers[0]);
```

### 二维数组

```
type arrayName[x][y];
```

初始化：

```
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```

- 内部嵌套的括号是可选的

- 二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。

### 指针

	int var = 10;
	int *p;
	p = &var;
	printf("1：%p\n", p);
	printf("2：%d\n", *p);
	printf("3：%d\n", var);
	printf("4：%p\n", &var);

输出为

1：000000C9292FF524
2：10
3：10
4：000000C9292FF524

**在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值。赋为 NULL 值的指针被称为空指针。**

在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

如需检查一个空指针，您可以使用 if 语句，如下所示：

if(ptr)     /* 如果 p 非空，则完成 */ if(!ptr)    /* 如果 p 为空，则完成 */

#### 指针的算术运算

C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、

- 指针的每一次递增，它其实会指向下一个元素的存储单元。
- 指针的每一次递减，它都会指向前一个元素的存储单元。
- 指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。

##### 指针的比较

- **相等比较 (`==` 和 `!=`)**: 用于判断两个指针是否指向相同的内存位置。
- **大小比较 (`<`, `>`, `<=`, `>=`)**: 通常用于指针遍历数组或内存块时，判断一个指针是否在另一个指针之前或之后。

#### 指针数组

指针数组存储了一组指针，每个指针可以指向**不同的数据对象**。

指针数组在C中非常有用，特别是在处理具有不定数量元素的数据结构时，如动态分配的字符串数组或动态创建的结构体数组。

#### 指向指针的指针

指向指针的指针是一种多级间接寻址的形式。

定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

```
#include <stdio.h>
 
int main ()
{
   int  V;
   int  *Pt1;
   int  **Pt2;
 
   V = 100;
 
   /* 获取 V 的地址 */
   Pt1 = &V;
 
   /* 使用运算符 & 获取 Pt1 的地址 */
   Pt2 = &Pt1;
 
   /* 使用 pptr 获取值 */
   printf("var = %d\n", V );
   printf("Pt1 = %p\n", Pt1 );
   printf("*Pt1 = %d\n", *Pt1 );
    printf("Pt2 = %p\n", Pt2 );
   printf("**Pt2 = %d\n", **Pt2);
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
var = 100
Pt1 = 0x7ffee2d5e8d8
*Pt1 = 100
Pt2 = 0x7ffee2d5e8d0
**Pt2 = 100
```

#### 传递指针给函数

```
#include <stdio.h>
#include <time.h>
 
void getSeconds(unsigned long *par);

int main ()
{
   unsigned long sec;


   getSeconds( &sec );

   /* 输出实际值 */
   printf("Number of seconds: %ld\n", sec );

   return 0;
}

void getSeconds(unsigned long *par)
{
   /* 获取当前的秒数 */
   *par = time( NULL );
   return;
}
```

#### 从函数返回指针

需要声明一个返回指针的函数，如下所示：

```
int * myFunction();
```

C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 **static** 变量。

### 函数指针

指向函数的指针变量。

```
#include <stdio.h>
 
int max(int x, int y)
{
    return x > y ? x : y;
}
 
int main(void)
{
    /* p 是函数指针 */
    int (* p)(int, int) = & max; // &可以省略
    int a, b, c, d;
 
    printf("请输入三个数字:");
    scanf("%d %d %d", & a, & b, & c);
 
    /* 与直接调用函数等价，d = max(max(a, b), c) */
    d = p(p(a, b), c); 
 
    printf("最大的数字是: %d\n", d);
 
    return 0;
}
```

### 回调函数

函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

实例：

```
#include <stdlib.h>  
#include <stdio.h>
 
void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
{
    for (size_t i=0; i<arraySize; i++)
        array[i] = getNextValue();
}
 
// 获取随机值
int getNextRandomValue(void)
{
    return rand();
}
 
int main(void)
{
    int myarray[10];
    /* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int , 而不是函数指针*/
    populate_array(myarray, 10, getNextRandomValue);
    for(int i = 0; i < 10; i++) {
        printf("%d ", myarray[i]);
    }
    printf("\n");
    return 0;
}
```

### 字符串

在 C 语言中，字符串实际上是使用空字符 \0 结尾的一维字符数组。因此，\0 是用于标记字符串的结束。

**空字符（Null character**）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。

```
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
```

```
char site[] = "RUNOOB";
```

二者等价。

操作字符串的函数：

| 序号 | 函数 & 目的                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。       |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

strcmp: string compare 

strcat: string catenate 

strcpy: string copy 

strlen: string length 

strlwr: string lowercase 

strupr: string upercase



**'a'** 表示是一个字符，**"a"** 表示一个字符串相当于 'a'+'\0';

'' 里面只能放一个字符;

"" 里面表示是字符串系统自动会在串末尾补一个 0。

### 结构体

**结构**是 C 编程中另一种**用户自定义**的可用的数据类型，它允许您**存储不同类型的数据项。**

可以是**基本数据类型（如 int、float、char 等）**，也可以是**其他结构体类型、指针类型**等。

为节省大小，各变量应按照数据类型所对应字节**由多到少或由少到多**排序。

```
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;  
```

在一般情况下，**tag、member-list、variable-list** 这 3 部分至少要出现 2 个。以下为实例：

```
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct 
{
    int a;
    char b;
    double c;
} s1;

//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量
struct SIMPLE
{
    int a;
    char b;
    double c;
};
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
struct SIMPLE t1, t2[20], *t3;

//也可以用typedef创建新类型
typedef struct
{
    int a;
    char b;
    double c; 
} Simple2;
//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;
```

结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。

如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：

```
struct B;   //对结构体B进行不完整声明
 
 //结构体A中包含指向结构体B的指针
 struct A
 {
   struct B *partner;
   //other members;
 };
 
 //结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明
 struct B
 {
   struct A *partner;
   //other members;
 };
```

#### 结构体变量的初始化

```
struct Books
 {
   char  title[50];
   char  author[50];
   char  subject[100];
   int  book_id;
 } book = {"C 语言", "RUNOOB", "编程语言", 123456};
```

#### 访问结构成员

**成员访问运算符（.）**

#### 指向结构的指针

为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符，

```
struct_pointer->title;
```

#### 结构体大小的计算

**sizeof** 将返回结构体的总字节数，包括所有成员变量的大小以及可能的填充字节。

**注意**，结构体的大小可能会受到编译器的优化和对齐规则的影响，编译器可能会在结构体中插入一些额外的填充字节以对齐结构体的成员变量，以提高内存访问效率。因此，结构体的实际大小可能会大于成员变量大小的总和，如果你需要确切地了解结构体的内存布局和对齐方式，可以使用 offsetof 宏和 __attribute__((packed)) 属性等进一步控制和查询结构体的大小和对齐方式。

结构体中成员变量分配的空间是按照成员变量中占用空间最大的来作为分配单位,同样成员变量的存储空间也是不能跨分配单位的,如果当前的空间不足,则会存储到下一个分配单位中。

```
#include <stdio.h>

typedef struct
{
    unsigned char a;
    unsigned int  b;
    unsigned char c;
} debug_size1_t;
typedef struct
{
    unsigned char a;
    unsigned char b;
    unsigned int  c;
} debug_size2_t;

int main(void)
{
    printf("debug_size1_t size=%lu,debug_size2_t size=%lu\r\n", sizeof(debug_size1_t), sizeof(debug_size2_t));
    return 0;
}
```

编译执行输出结果：

```
debug_size1_t size=12,debug_size2_t size=8
```

结构体占用存储空间,以32位机为例

- 1.debug_size1_t 存储空间分布为a(1byte)+空闲(3byte)+b(4byte)+c(1byte)+空闲(3byte)=12(byte)。
- 1.debug_size2_t 存储空间分布为a(1byte)+b(1byte)+空闲(2byte)+c(4byte)=8(byte)。

### 共用体

**共用体**是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

用于多个不同类型变量不同时使用的情况，用于节省空间。

```
union Data
{
   int i;
   float f;
   char  str[20];
} data;
```

共用体占用的内存应足够存储共用体中最大的成员。

#### 访问共用体成员

使用**成员访问运算符（.）**

### 位域

一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的**位**数。

```
struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status;
```

上面的结构中，status 变量将占用 **4 个字节**的内存空间（最少），但是只有 2 位被用来存储值。

- 定义位域时，可以指定成员的位域宽度，即成员所占用的位数。
- 位域的宽度不能超过其数据类型的大小，因为位域必须适应所使用的整数类型。

一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：

```
struct bs{
    unsigned a:4;
    unsigned  :4;    /* 空域 */
    unsigned b:4;    /* 从下一单元开始存放 */
    unsigned c:4
}
```

位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。

### typedef

为类型取一个新的名字。如：

```
typedef unsigned char BYTE;
```

按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母。

```
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} Book;
//Book是新的结构体类型名
```

#### 与#define区别

- **typedef** 仅限于为类型定义符号名称，**# define** 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。
- **typedef** 是由编译器执行解释的，**# define** 语句是由预编译器进行处理的。

-  # define可以使用其他类型说明符对宏类型名进行扩展，但对 typedef 所定义的类型名却不能这样做。例如：

```
#define INTERGE int;
unsigned INTERGE n;  //没问题
typedef int INTERGE;
unsigned INTERGE n;  //错误，不能在 INTERGE 前面添加 unsigned
```

-  在连续定义几个变量的时候，typedef 能够保证定义的所有变量均为同一类型，而 # define 则无法保证。例如：

```
#define PTR_INT int *
PTR_INT p1, p2;        //p1、p2 类型不相同，宏展开后变为int *p1, p2;
typedef int * PTR_INT
PTR_INT p1, p2;        //p1、p2 类型相同，它们都是指向 int 类型的指针。
```

### 输入 & 输出

#### 标准文件

C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。

| 标准文件 | 文件指针 | 设备     |
| -------- | -------- | -------- |
| 标准输入 | stdin    | 键盘     |
| 标准输出 | stdout   | 屏幕     |
| 标准错误 | stderr   | 您的屏幕 |

#### scanf() 和 printf() 函数

**int scanf(const char \*format, ...)** 函数从标准输入流 **stdin** 读取输入，并根据提供的 **format** 来浏览输入。

传递数据给变量时，需要传入它们的**地址**或指向它们的**指针**。

另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 "this is test" 对 scanf() 来说是三个字符串。

**int printf(const char \*format, ...)** 函数把输出写入到标准输出流  **stdout** ，并根据提供的格式产生输出。

**format** 可以是一个简单的**常量字符串**，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。

```
printf("<格式化字符串>", <参量表>);
```

##### 规定符

- **%d** 十进制有符号整数

- **%u** 十进制无符号整数

- **%f** 浮点数

- **%s** 字符串

- **%c** 单个字符

- **%p** 指针的值

- **%e** 指数形式的浮点数

- **%x, %X** 无符号以十六进制表示的整数

- **%o** 无符号以八进制表示的整数

- **%g** 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出

- **%p** 输出地址符

- **%lu** 32位无符号整数

- **%llu** 64位无符号整数

- **%%** 输出百分号字符本身。

- 除了格式化说明符之外，printf() 函数还支持一些标志和选项，用于控制输出的精度、宽度、填充字符和对齐方式等。例如：

  - **%-10s**：左对齐并占用宽度为 10 的字符串；
  - **%5.2f**：右对齐并占用宽度为 5，保留两位小数的浮点数；
  - **%#x**：输出带有 0x 前缀的十六进制数。

  printf() 函数也支持变长参数列表，可以使用省略号 ... 来表示，用于指定要输出的多个值。

  **附加参数** -- 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。**参数的个数应与 % 标签的个数相同。**

#### getchar() & putchar() 函数

**int getchar(void)** 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。

**int putchar(int c)** 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。

#### gets() & puts() 函数（疑似不能使用）

**char \*gets(char \*s)** 函数从 **stdin** 读取一行到 **s** 所指向的缓冲区，直到一个终止符或 EOF。

**int puts(const char \*s)** 函数把字符串 s 和一个尾随的换行符写入到 **stdout**。

#### scanf() 和 printf() 函数

**int scanf(const char \*format, ...)** 函数从标准输入流 **stdin** 读取输入，并根据提供的 **format** 来浏览输入。

**int printf(const char \*format, ...)** 函数把输出写入到标准输出流  **stdout** ，并根据提供的格式产生输出。

### 文件读写

#### 打开文件

使用 **fopen( )** 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 **FILE** 的一个对象，类型 **FILE** 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：

```
FILE *fopen( const char *filename, const char *mode );
```

**filename** 是字符串，用来命名文件，访问模式 **mode** 的值可以是下列值中的一个：

| 模式 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| r    | 打开一个已有的文本文件，允许读取文件。                       |
| w    | 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 |
| a    | 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 |
| r+   | 打开一个文本文件，允许读写文件。                             |
| w+   | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件，如果文件已存在，则文件会被截断为零长度。 |
| a+   | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 |

如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：

```
"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"
```

#### 写入文件

##### **fputc()** 

```
int fputc( int c, FILE *fp );
```

函数 **fputc()** 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 **EOF**。

##### **fprintf**

```
int fprintf(FILE *fp,const char *format, ...);
```

> **注意：**请确保您有可用的 **tmp** 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。
>
> /tmp 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: C:\tmp、D:\tmp等。

```
#include <stdio.h>
 
int main()
{
   FILE *fp = NULL;
 
   fp = fopen("/tmp/test.txt", "w+");
   fprintf(fp, "This is testing for fprintf...\n");
   fputs("This is testing for fputs...\n", fp);
   fclose(fp);
}
```

#### 读取文件

##### fgetc()

```
int fgetc( FILE * fp );
```

从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 **EOF**。

##### fgets()读字符串：

```
char *fgets( char *buf, int n, FILE *fp );
```

函数 **fgets()** 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 **buf**，并在最后追加一个 **null** 字符来终止字符串。

如果这个函数在读取最后一个字符之前就遇到一个换行符 '\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。

##### **fscanf()**

您也可以使用 **int fscanf(FILE \*fp, const char \*format, ...)** 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。

```
#include <stdio.h>

int main()
{
	FILE* fp = NULL;
	char buff[255];

	fp = fopen("/tmp/test.txt", "r");
	fscanf(fp, "%s", buff);
	printf("1: %s\n", buff);

	fgets(buff, 255, (FILE*)fp);
	printf("2: %s\n", buff);

	fgets(buff, 255, (FILE*)fp);
	printf("3: %s\n", buff);
	fclose(fp);

}
```

以下为控制台输出：

```
1: This
2:  is testing for fprintf...

3: This is testing for fputs...

```

#### 关闭文件

为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：

```
 int fclose( FILE *fp );
```

如果成功关闭文件，**fclose( )** 函数返回**零**，如果关闭文件时发生错误，函数返回 **EOF**。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 **stdio.h** 中的常量。

#### 二进制 I/O 函数

下面两个函数用于二进制输入和输出：

```
size_t fread(void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
              
size_t fwrite(const void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
```

这两个函数都是用于存储块的读写 - 通常是数组或结构体。

### 预处理器

只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。

以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：

| 指令     | 描述                                                        |
| -------- | ----------------------------------------------------------- |
| # define  | 定义宏                                                      |
| # include | 包含一个源代码文件                                          |
| # undef   | 取消已定义的宏                                              |
| # ifdef   | 如果宏已经定义，则返回真                                    |
| # ifndef  | 如果宏没有定义，则返回真                                    |
| # if      | 如果给定条件为真，则编译下面代码                            |
| # else    | # if 的替代方案                                              |
| # elif    | 如果前面的 # if 给定条件不为真，当前条件为真，则编译下面代码 |
| # endif   | 结束一个 # if……#else 条件编译块                              |
| # error   | 当遇到标准错误时，输出错误消息                              |
| # pragma  | 使用标准化方法，向编译器发布特殊的命令到编译器中            |

```
#include <stdio.h>
#include "myheader.h"
```

上述指令告诉 CPP 从**系统库**中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 **myheader.h**，并添加内容到当前的源文件中。

```
#undef  FILE_SIZE
#define FILE_SIZE 42
```

这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。

```
#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif
```

这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。

```
#ifdef DEBUG
   /* Your debugging statements here */
#endif
```

这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 *-DDEBUG* 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。

#### 预定义宏

ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。

| 宏       | 描述                                                |
| -------- | --------------------------------------------------- |
| __DATE__ | 当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。 |
| __TIME__ | 当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。    |
| __FILE__ | 这会包含当前文件名，一个字符串常量。                |
| __LINE__ | 这会包含当前行号，一个十进制常量。                  |
| __STDC__ | 当编译器以 ANSI 标准编译时，则定义为 1。            |

如：

```
File :test.c
Date :Jun 2 2012
Time :03:36:24
Line :8
ANSI :1
```

#### 预处理器运算符

##### 宏延续运算符（\）

一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：

```
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")
```

##### 字符串常量化运算符（#）（无用）

在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：

```
#include <stdio.h>
 
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")
 
int main(void)
{
   message_for(Carole, Debra);
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Carole and Debra: We love you!
```

##### 标记粘贴运算符（##）（无用）

宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。

```
#include <stdio.h>
 
#define tokenpaster(n) printf ("token" #n " = %d", token##n)
 
int main(void)
{
   int token34 = 40;
   
   tokenpaster(34);
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
token34 = 40
```

这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：

```
printf ("token34 = %d", token34);
```

这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了**字符串常量化运算符（#）**和**标记粘贴运算符（##）**。

#### 参数化的宏

CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：

```
int square(int x) {
   return x * x;
}
```

我们可以使用宏重写上面的代码，如下：

```
#define square(x) ((x) * (x))
```

在使用带有参数的宏之前，必须使用 **# define** 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：

```
#include <stdio.h>
 
#define MAX(x,y) ((x) > (y) ? (x) : (y))
 
int main(void)
{
   printf("Max between 20 and 10 is %d\n", MAX(10, 20));  
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Max between 20 and 10 is 20
```

### 关于使用异或运算交换两数的值

异或运算可以达到交换两数的目的，代码如下:

```
void swap(int &a, int &b)
{
    a = a^b;
    b = a^b;
    a = a^b;
}
```

**但不推荐使用这种方式**，附上常用的临时变量方法对比说明。

临时变量方法:

```
void swap(int &a, int &b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

对于临时变量法，每次赋值只要读取一个变量的值到寄存器，然后再从寄存器写回到另一个变量中即可，前后涉及两次内存写入操作；但是对于异或运算操作，每次都需要读取两个数据到寄存器中，再进行运算操作，之后把结果写回到变量中，前后共需要三次内存写入操作。另外一点，异或操作的代码可读性差。

如果使用C语言实现上述两种方法，并用gcc编译器编译，可以使用命令 gcc -S swap.c 查看相应的汇编代码，临时变量法代码行数更少，另外使用 **gcc** 编译器时，用异或运算交换数组会出错，参见链接。

在不引入临时变量的基础上，交换两数的值还可以使用三次加减法，代码如下:

```
void swap(int &a, int &b)
{
    a = a + b;
    b = a - b;
    a = a - b;
}
```

这种方式同样需要三次内存写入操作，同时代码可读性也较差。

### 头文件

头文件是扩展名为 **.h** 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。

在程序中要使用头文件，需要使用 C 预处理指令 ** # include** 来引用它。前面我们已经看过 **stdio.h** 头文件，它是编译器自带的头文件。

引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。

建议把所有的**常量、宏、系统全局变量和函数原型**写在头文件中，在需要的时候随时引用这些头文件。

#### 引用头文件的语法

使用预处理指令 ** # include** 可以引用用户和系统头文件。它的形式有以下两种：

```
#include <file>
```

这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。

```
#include "file"
```

这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。

#### 只引用一次头文件

如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：

```
#ifndef HEADER_FILE
#define HEADER_FILE

the entire header file file

#endif
```

这种结构就是通常所说的包装器 ** # ifndef**。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。

#### 有条件引用（无用）

有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：

```
#if SYSTEM_1
   # include "system_1.h"
#elif SYSTEM_2
   # include "system_2.h"
#elif SYSTEM_3
   ...
#endif
```

但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的**有条件引用**。它不是用头文件的名称作为 ** # include** 的直接参数，您只需要使用宏名称代替即可：

```
 #define SYSTEM_H "system_1.h"
 ...
 #include SYSTEM_H
```

SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 ** # include** 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。

### 强制类型转换

```
(type_name) expression
```

```
mean = (double) sum / count;
```

类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用**强制类型转换运算符**来指定。在编程时，**有需要类型转换的时候都用上强制类型转换运算符**，是一种良好的编程习惯。

#### 整数提升

是指把小于 **int** 或 **unsigned int** 的整数类型转换为 **int** 或 **unsigned int** 的过程。

#### 常用的算术转换

**常用的算术转换**是隐式地把值强制转换为相同的类型。编译器首先执行**整数提升**，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：

![Usual Arithmetic Conversion](https://www.runoob.com/wp-content/uploads/2014/08/usual_arithmetic_conversion.png)

常用的算术转换不适用于赋值运算符、逻辑运算符 && 和 ||。

### 错误处理

C 语言不提供对错误处理的直接支持，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 **errno**，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。

所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。

#### errno、perror() 和 strerror()

- **perror()** 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。
- **strerror()** 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。

```
#include <stdio.h>
#include <errno.h>
#include <string.h>
 
extern int errno ;
 
int main ()
{
   FILE * pf;
   int errnum;
   pf = fopen ("unexist.txt", "rb");
   if (pf == NULL)
   {
      errnum = errno;
      fprintf(stderr, "错误号: %d\n", errno);
      perror("通过 perror 输出错误");
      fprintf(stderr, "打开文件错误: %s\n", strerror( errnum ));
   }
   else
   {
      fclose (pf);
   }
   return 0;
}
```

```
错误号: 2
通过 perror 输出错误: No such file or directory
打开文件错误: No such file or directory
```

#### 被零除的错误

进行除法运算前会先检查除数是否为零，如果除数为零，则会导致一个运行时错误。

```
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
   int dividend = 20;
   int divisor = 0;
   int quotient;
 
   if( divisor == 0){
      fprintf(stderr, "除数为 0 退出运行...\n");
      exit(-1);
   }
   quotient = dividend / divisor;
   fprintf(stderr, "quotient 变量的值为 : %d\n", quotient );
 
   exit(0);
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
除数为 0 退出运行...
```

#### 程序退出状态

通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。

如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1

### 递归

C 语言支持递归，即一个函数可以调用其自身。但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入死循环。

#### 数的阶乘

使用递归函数计算一个给定的数的阶乘：

```
double factorial(unsigned int i)
{
   if(i <= 1)
   {
      return 1;
   }
   return i * factorial(i - 1);
}
```

#### 斐波那契数列

使用递归函数生成一个给定的数的斐波那契数列：

```
int fibonaci(int i)
{
   if(i == 0)
   {
      return 0;
   }
   if(i == 1)
   {
      return 1;
   }
   return fibonaci(i-1) + fibonaci(i-2);
}
```

### 可变参数（看不明白）

使函数带有可变数量的参数，而不是预定义数量的参数。

```
int func_name(int arg1, ...);
```

省略号 ... 表示可变参数列表。

需要使用 **stdarg.h** 头文件。

请注意，函数 **func()** 最后一个参数写成省略号，即三个点号（**...**），省略号之前的那个参数是 **int**，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 **stdarg.h** 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：

- 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。
- 在函数定义中创建一个 **va_list** 类型变量，该类型是在 stdarg.h 头文件中定义的。
- 使用 **int** 参数和 **va_start()** 宏来初始化 **va_list** 变量为一个参数列表。宏 **va_start()** 是在 stdarg.h 头文件中定义的。
- 使用 **va_arg()** 宏和 **va_list** 变量来访问参数列表中的每个项。
- 使用宏 **va_end()** 来清理赋予 **va_list** 变量的内存。

常用的宏有：

- `va_start(ap, last_arg)`：初始化可变参数列表。`ap` 是一个 `va_list` 类型的变量，`last_arg` 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 `ap` 指向可变参数列表中的第一个参数。
- `va_arg(ap, type)：获取可变参数列表中的下一个参数。`ap` 是一个 `va_list` 类型的变量，`type` 是下一个参数的类型。该宏返回类型为 `type` 的值，并将 `ap` 指向下一个参数。
- `va_end(ap)`：结束可变参数列表的访问。`ap` 是一个 `va_list` 类型的变量。该宏将 `ap` 置为 `NULL`。

```
double average(int num,...)
{
 
    va_list valist;
    double sum = 0.0;
    int i;
 
    /* 为 num 个参数初始化 valist */
    va_start(valist, num);
 
    /* 访问所有赋给 valist 的参数 */
    for (i = 0; i < num; i++)
    {
       sum += va_arg(valist, int);
    }
    /* 清理为 valist 保留的内存 */
    va_end(valist);
 
    return sum/num;
}
```

第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。

### 内存管理

这些函数可以在 **<stdlib.h>** 头文件中找到。

| 序号 | 函数和描述                                                   |
| ---- | ------------------------------------------------------------ |
| 1    | **void \*calloc(int num, int size);** 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是 0。 |
| 2    | **void free(void \*address);**  该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 |
| 3    | **void \*malloc(int num);**  在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 |
| 4    | **void \*realloc(void \*address, int newsize);**  该函数重新分配内存，把内存扩展到 **newsize**。 |

**注意：**void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。

#### 动态分配内存

定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存

如：

```
   char name[100];
   char *description;
 
   strcpy(name, "Zara Ali");
 
   /* 动态分配内存 */
   description = (char *)malloc( 200 * sizeof(char) );//calloc(200, sizeof(char))
   /* 检测是否成功分配 */
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student in class 10th");
   }
```

#### 重新调整内存的大小和释放内存

当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 **free()** 来释放内存。

或者，您可以通过调用函数 **realloc()** 来增加或减少已分配的内存块的大小。

#### 其他

- memcpy() 函数：用于从源内存区域复制数据到目标内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。
- memmove() 函数：类似于 memcpy() 函数，但它可以处理重叠的内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。

### 未定义行为

可能会产生不可预测的结果，包括程序崩溃、数据损坏、安全漏洞，甚至可能看起来正常运行。

涉及到程序的正确性和安全性。

#### 数组越界 

#### 解引用空指针

#### 未初始化的局部变量

#### 浮点数除以零/整数除以零

#### 符号溢出

当整数运算导致结果超出了整数类型能表示的范围时，结果是未定义的。

#### 位移操作数太大

当执行位移操作时，位移的位数大于或等于操作数的位数时，结果是未定义的。

```
int x = 1;
int y = x << 32; // 位移操作数太大，结果未定义
```

### 错误的类型转换

当我们进行不安全的类型转换时，结果是未定义的。例如：

```
int *ptr = (int *)malloc(sizeof(int));
float *fptr = (float *)ptr; // 错误的类型转换，结果未定义
```

1. 可能导致越界访问，引发安全问题。
2. 如果 `ptr` 和 `fptr` 指向同一块内存，并且你尝试释放它们，那么第一次 `free` 调用是正确的，但是第二次 `free` 调用将尝试释放已经被释放的内存，这可能导致内存损坏。

#### 内存越界

当我们向已经释放或未分配的内存写入数据时，结果是未定义的。

#### 未定义的浮点数行为

比如比较两个 NaN（非数字）值是否相等，这是未定义的行为。



```
float x = sqrt(-1);//返回 ‘NaN’（不是一个数字）
float y = sqrt(-1);//返回 ‘NaN’（不是一个数字）
if (x == y) {
    printf("NaN values are equal\n");
}
```

#### 其他：

- **使用未定义的浮点数特性：**依赖于特定硬件或实现的浮点数行为，如浮点数的精度或舍入行为。
- **函数参数数量不匹配：**调用函数时提供的参数数量与函数定义不匹配，如 printf("%s %d", "Name")。
- **修改字符串字面量：**尝试修改字符串字面量的内容，如 char *str = "Hello"; str[0] = 'h';。
- **使用未定义的程序状态：**依赖于未定义的程序状态，如全局变量的初始值。
- **违反严格的语法规则：**违反 C 语言的严格语法规则，如使用未声明的标识符。
- **多线程中的竞态条件：**在多线程环境中，未同步的共享资源访问可能导致未定义行为。
- **使用未定义的标准库函数行为：**某些标准库函数在特定条件下的行为可能是未定义的，如 fscanf() 在未匹配到任何输入时的行为。

### 命令行参数

执行程序时，可以从命令行传值给 C 程序。这些值被称为**命令行参数**，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。

一种从命令行获取输入的方法，可以用于运行程序时传递信息给程序。命令行参数通过 main 函数的参数传递给程序。main 函数的原型可以是如下两种形式之一：

```
int main(int argc, char *argv[]);
```

或者:

```
int main(int argc, char **argv);
```

- **`argc` (argument count)**: 表示命令行参数的数量，包括程序名本身。因此，`argc` 至少为 1。
- **`argv` (argument vector)**: 是一个指向字符串数组的指针，其中每个字符串是一个命令行参数。数组的第一个元素（即 `argv[0]`）通常是程序的名称。接下来的元素是传递给程序的命令行参数。

检查命令行是否有提供参数，并根据参数执行相应的动作：

```
#include <stdio.h>

int main( int argc, char *argv[] )  
{
   if( argc == 2 )
   {
      printf("The argument supplied is %s\n", argv[1]);
   }
   else if( argc > 2 )
   {
      printf("Too many arguments supplied.\n");
   }
   else
   {
      printf("One argument expected.\n");
   }
}
```

使用一个参数，编译并执行上面的代码，它会产生下列结果：

```
$./a.out testing
The argument supplied is testing
```

不传任何参数，编译并执行上面的代码，它会产生下列结果：

```
$./a.out
One argument expected
```

**argv[0]** 存储程序的名称，**argv[1]** 是一个指向第一个命令行参数的指针。

多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 "" 或单引号 '' 内部。

#### 使用场景

命令行参数在许多情况下都很有用，例如：

- **配置文件路径**
- **模式选择**（例如调试模式）
- 输入文件和输出文件名
- **运行时选项和标志**（如 `-v` 表示详细模式）

#### 注意事项

- 命令行参数通常是**字符串**，如果需要将其转换为数值类型，可以使用标准库函数如 `atoi` 或 `strtol`。
- 应该**始终验证和处理命令行参数，以防止输入错误或恶意输入。**

### 排序算法

#### 冒泡排序

![img](https://www.runoob.com/wp-content/uploads/2018/09/Bubble_sort_animation.gif)

它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。

```
// 冒泡排序函数
void bubble_sort(int arr[], int len) {
    for (int i = 0; i < len - 1; i++) {
        for (int j = 0; j < len - 1 - i; j++) {
            // 交换元素位置
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

#### 选择排序

![img](https://www.runoob.com/wp-content/uploads/2018/09/Selection_sort_animation.gif)

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

```
// 选择排序函数
void selection_sort(int a[], int len) {
    for (int i = 0; i < len - 1; i++) {
        int min = i;  // 记录最小值的位置，第一个元素默认最小
        for (int j = i + 1; j < len; j++) {
            if (a[j] < a[min]) {  // 找到目前最小值
                min = j;  // 记录最小值的位置
            }
        }
        // 交换两个变量
        if (min != i) {
            int temp = a[min];
            a[min] = a[i];
            a[i] = temp;
        }
    }
}
//从第一个开始往后比较，最小的与第一个交换位置，随后从第二个开始向后比较，最小的放在前边，以此类推
```

#### 插入排序

![img](https://www.runoob.com/wp-content/uploads/2018/09/Insertion_sort_animation.gif)

通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle  O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后

挪位，为最新元素提供插入空间。

```
// 插入排序函数
void insertion_sort(int arr[], int len) {
    for (int i = 1; i < len; i++) {
        int temp = arr[i];  // 当前待插入的元素
        int j = i;
        // 向右移动大于temp的元素
        while (j > 0 && arr[j - 1] > temp) {
            arr[j] = arr[j - 1];
            j--;
        }
        arr[j] = temp;  // 插入元素到正确位置
    }
}
```

#### 希尔排序

![img](https://www.runoob.com/wp-content/uploads/2018/09/Sorting_shellsort_anim.gif)

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

```
// 希尔排序函数
void shell_sort(int arr[], int len) {
    // 计算初始间隔
    for (int gap = len / 2; gap > 0; gap /= 2) {
        // 对每个间隔进行插入排序
        for (int i = gap; i < len; i++) {
            int temp = arr[i];  // 当前待插入的元素
            int j = i;
            // 移动大于temp的元素
            while (j >= gap && arr[j - gap] > temp) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;  // 插入元素到正确位置
        }
    }
}
```

#### 归并排序

![img](https://www.runoob.com/wp-content/uploads/2018/09/Merge_sort_animation2.gif)

把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。

可从上到下或从下到上进行。

迭代法：

```
void merge_sort(int arr[], int len) {
    int* a = arr;
    int* b = (int*) malloc(len * sizeof(int));
 
    if (b == NULL) {  // 检查内存分配是否成功
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
 
    for (int seg = 1; seg < len; seg += seg) {
        for (int start = 0; start < len; start += seg + seg) {
            int low = start;
            int mid = min(start + seg, len);
            int high = min(start + seg + seg, len);
            int k = low;
            int start1 = low, end1 = mid;
            int start2 = mid, end2 = high;
 
            // 合并两个子数组
            while (start1 < end1 && start2 < end2) {
                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];
            }
            while (start1 < end1) {
                b[k++] = a[start1++];
            }
            while (start2 < end2) {
                b[k++] = a[start2++];
            }
        }
 
        // 交换数组指针
        int* temp = a;
        a = b;
        b = temp;
    }
 
    // 如果a和arr不相同，则将a的内容复制回arr
    if (a != arr) {
        for (int i = 0; i < len; i++) {
            b[i] = a[i];
        }
        b = a;
    }
 
    free(b);  // 释放内存
}
```

递归法：

```
// 递归实现归并排序
void merge_sort_recursive(int arr[], int reg[], int start, int end) {
    if (start >= end)
        return;
 
    int mid = start + (end - start) / 2;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
 
    merge_sort_recursive(arr, reg, start1, end1);
    merge_sort_recursive(arr, reg, start2, end2);
 
    int k = start;
    while (start1 <= end1 && start2 <= end2) {
        reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
    }
    while (start1 <= end1) {
        reg[k++] = arr[start1++];
    }
    while (start2 <= end2) {
        reg[k++] = arr[start2++];
    }
 
    // 使用memcpy进行数组复制，提高效率
    memcpy(arr + start, reg + start, (end - start + 1) * sizeof(int));
}
 
// 归并排序入口函数
void merge_sort(int arr[], const int len) {
    int* reg = (int*)malloc(len * sizeof(int));
    if (reg == NULL) {  // 检查内存分配是否成功
        fprintf(stderr, "Memory allocation failed\n");
        exit(EXIT_FAILURE);
    }
    merge_sort_recursive(arr, reg, 0, len - 1);
    free(reg);  // 释放内存
}
```

#### 快速排序

![img](https://www.runoob.com/wp-content/uploads/2018/09/Sorting_quicksort_anim.gif)

在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。

递归法：

```c
// 递归实现快速排序
void quick_sort_recursive(int arr[], int start, int end) {
    if (start >= end)
        return;
 
    int mid = arr[end];
    int left = start, right = end - 1;
 
    while (left < right) {
        while (left < right && arr[left] < mid)
            left++;
        while (left < right && arr[right] >= mid)
            right--;
        swap(&arr[left], &arr[right]);
    }
 
    if (arr[left] >= arr[end])
        swap(&arr[left], &arr[end]);
    else
        left++;
 
    quick_sort_recursive(arr, start, left - 1);
    quick_sort_recursive(arr, left + 1, end);
}
 
// 快速排序入口函数
void quick_sort(int arr[], int len) {
    quick_sort_recursive(arr, 0, len - 1);
}

```

迭代法：

```c
// 快速排序函数
void quick_sort(int arr[], const int len) {
    if (len <= 0)
        return; // 避免 len 等于负值时引发段错误（Segment Fault）
 
    Range r[len];
    int p = 0;
    r[p++] = new_Range(0, len - 1);
 
    while (p > 0) {
        Range range = r[--p];
        if (range.start >= range.end)
            continue;
 
        int mid = arr[(range.start + range.end) / 2]; // 选取中间点为基准点
        int left = range.start, right = range.end;
 
        do {
            while (arr[left] < mid) ++left;   // 检测基准点左侧是否符合要求
            while (arr[right] > mid) --right; // 检测基准点右侧是否符合要求
 
            if (left <= right) {
                swap(&arr[left], &arr[right]);
                left++;
                right--; // 移动指针以继续
            }
        } while (left <= right);
 
        if (range.start < right) r[p++] = new_Range(range.start, right);
        if (range.end > left) r[p++] = new_Range(left, range.end);
    }
}
```

### 实例：

https://www.runoob.com/cprogramming/c-examples.html

### 经典100例

https://www.runoob.com/cprogramming/c-100-examples.html

## C++

### 日期 & 时间

C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <ctime> 头文件。

有四个与时间相关的类型：**clock_t、time_t、size_t** 和 **tm**。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。

结构类型 **tm** 把日期和时间以 C 结构的形式保存，tm 结构的定义如下：

```
struct tm {
  int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61
  int tm_min;   // 分，范围从 0 到 59
  int tm_hour;  // 小时，范围从 0 到 23
  int tm_mday;  // 一月中的第几天，范围从 1 到 31
  int tm_mon;   // 月，范围从 0 到 11
  int tm_year;  // 自 1900 年起的年数
  int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起
  int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起
  int tm_isdst; // 夏令时
};
```

下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。

| 序号 | 函数 & 描述                                                  |
| ---- | ------------------------------------------------------------ |
| 1    | [**time_t time(time_t \*time);**](https://www.runoob.com/cplusplus/c-function-time.html) 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。 |
| 2    | [**char \*ctime(const time_t \*time);**](https://www.runoob.com/cplusplus/c-function-ctime.html) 该返回一个表示当地时间的字符串指针，字符串形式 *day month year hours:minutes:seconds year\n\0*。 |
| 3    | [**struct tm \*localtime(const time_t \*time);**](https://www.runoob.com/cplusplus/c-function-localtime.html) 该函数返回一个指向表示本地时间的 **tm** 结构的指针。 |
| 4    | [**clock_t clock(void);**](https://www.runoob.com/cplusplus/c-function-clock.html) 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。 |
| 5    | [**char \* asctime ( const struct tm \* time );**](https://www.runoob.com/cplusplus/c-function-asctime.html) 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。 |
| 6    | [**struct tm \*gmtime(const time_t \*time);**](https://www.runoob.com/cplusplus/c-function-gmtime.html) 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 |
| 7    | [**time_t mktime(struct tm \*time);**](https://www.runoob.com/cplusplus/c-function-mktime.html) 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 |
| 8    | [**double difftime ( time_t time2, time_t time1 );**](https://www.runoob.com/cplusplus/c-function-difftime.html) 该函数返回 time1 和 time2 之间相差的秒数。 |
| 9    | [**size_t strftime();**](https://www.runoob.com/cplusplus/c-function-strftime.html) 该函数可用于格式化日期和时间为指定的格式。 |

```C++
#include <iostream>
#include <ctime>
 
using namespace std;
 
int main( )
{
   // 基于当前系统的当前日期/时间
   time_t now = time(0);
   
   // 把 now 转换为字符串形式
   char* dt = ctime(&now);
 
   cout << "本地日期和时间：" << dt << endl;
 
   // 把 now 转换为 tm 结构
   tm *gmtm = gmtime(&now);
   dt = asctime(gmtm);
   cout << "UTC 日期和时间："<< dt << endl;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
本地日期和时间：Sat Jan  8 20:07:41 2011

UTC 日期和时间：Sun Jan  9 03:07:41 2011
```

#### 使用结构 tm 格式化时间

**tm** 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。

在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -> 运算符来访问结构成员。

```c++
#include <iostream>
#include <ctime>
 
using namespace std;
 
int main( )
{
   // 基于当前系统的当前日期/时间
   time_t now = time(0);
 
   cout << "1970 到目前经过秒数:" << now << endl;
 
   tm *ltm = localtime(&now);
 
   // 输出 tm 结构的各个组成部分
   cout << "年: "<< 1900 + ltm->tm_year << endl;
   cout << "月: "<< 1 + ltm->tm_mon<< endl;
   cout << "日: "<<  ltm->tm_mday << endl;
   cout << "时间: "<< ltm->tm_hour << ":";
   cout << ltm->tm_min << ":";
   cout << ltm->tm_sec << endl;
}
```

```
当上面的代码被编译和执行时，它会产生下列结果：
1970 到目前时间:1503564157
年: 2017
月: 8
日: 24
时间: 16:42:37
```

### 基本的输入输出

| 头文件                                                       | 函数和描述                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [<iostream>](https://www.runoob.com/cplusplus/cpp-libs-iostream.html) | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |

#### 标准输出流（cout）

#### 标准输入流（cin）

#### 标准错误流（cerr）

预定义的对象 **cerr** 是 **iostream** 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 **cerr** 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。

**cerr** 也是与流插入运算符 << 结合使用的，如下所示：

```
#include <iostream>

using namespace std;

int main( )
{
   char str[] = "Unable to read....";

   cerr << "Error message : " << str << endl;
}
```

#### 标准日志流（clog）

预定义的对象 **clog** 是 **iostream** 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 **clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。

**clog** 也是与流插入运算符 << 结合使用的，如下所示：

```
#include <iostream>
 
using namespace std;
 
int main( )
{
   char str[] = "Unable to read....";
 
   clog << "Error message : " << str << endl;
}
```

通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。

### 结构特性

**访问权限：**与 class 类似，你可以在 struct 中使用 public、private 和 protected 来定义成员的访问权限。在 struct 中，默认所有成员都是 public，而 class 中默认是 private。

#### 指向结构的指针

为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符，如下所示：

```
struct_pointer->title;
```

#### 结构体与类的区别

在 C++ 中，struct 和 class 本质上非常相似，唯一的区别在于默认的访问权限：

- `struct` 默认的成员和继承是 `public`。
- `class` 默认的成员和继承是 `private`。

你可以将 `struct` 当作一种简化形式的 `class`，适合用于没有太多复杂功能的简单数据封装。

### 结构体与函数的结合

你可以通过构造函数初始化结构体，还可以通过引用传递结构体来避免不必要的拷贝。

结构体可以包含**成员函数**。

```
struct Books {
    string title;
    string author;
    string subject;
    int book_id;

    // 构造函数
    Books(string t, string a, string s, int id)
        : title(t), author(a), subject(s), book_id(id) {}

    void printInfo() const {
        cout << "书籍标题: " << title << endl;
        cout << "书籍作者: " << author << endl;
        cout << "书籍类目: " << subject << endl;
        cout << "书籍 ID: " << book_id << endl;
    }
};

void printBookByRef(const Books& book) {
    book.printInfo();
}
```

### vector 容器

C++ 中的 vector 是一种序列容器，它允许你在运行时**动态地插入和删除元素**。

vector 是基于数组的数据结构，但它可以**自动管理内存**，这意味着你**不需要手动分配和释放内存**。

与 C++ 数组相比，vector 具有更多的灵活性和功能，使其成为 C++ 中常用的数据结构之一。

vector 是 C++ 标准模板库（STL）的一部分，提供了灵活的接口和高效的操作。

**基本特性:**

- **动态大小**：`vector` 的**大小可以根据需要自动增长和缩小**。
- **连续存储**：`vector` 中的**元素在内存中是连续存储**的，这使得**访问元素非常快速**。
- **可迭代**：`vector` **可以被迭代**，你**可以使用循环（如 `for` 循环）来访问它的元素**。
- **元素类型**：`vector` **可以存储任何类型的元素**，包括内置类型、对象、指针等。

**使用场景：**

- 当你需要一个可以**动态增长和缩小的数组**时。
- 当你需要**频繁地在序列的末尾添加或移除元素**时。
- 当你需要一个可以**高效随机访问元素的容器**时。



要使用 vector，首先需要**包含** <vector> 头文件：

```
#include <vector>
```

**创建**：

```c++
std::vector<int> myVector; // 创建一个存储整数的空 vector
std::vector<int> myVector(5); // 创建一个包含 5 个整数的 vector，每个值都为默认值（0）
std::vector<int> myVector(5, 10); // 创建一个包含 5 个整数的 vector，每个值都为 10
std::vector<int> vec; // 默认初始化一个空的 vector
std::vector<int> vec2 = {1, 2, 3, 4}; // 初始化一个包含元素的 vector
```

向 vector 中**添加**元素：

```
myVector.push_back(7); // 将整数 7 添加到 vector 的末尾
```

使用下标操作符 [] 或 at() 方法**访问** vector 中的元素：

```
int x = myVector[0]; // 获取第一个元素
int y = myVector.at(1); // 获取第二个元素
```

**获取** vector 中元素的**数量**：

```
int size = myVector.size(); // 获取 vector 中的元素数量
```

使用迭代器**遍历** vector 中的元素：

```
for (auto it = myVector.begin(); it != myVector.end(); ++it) {
    std::cout << *it << " ";
}
```

使用范围循环：

```
for (int element : myVector) {
    std::cout << element << " ";
}
```

**删除** vector 中的元素：

```
myVector.erase(myVector.begin() + 2); // 删除第三个元素
```

**清空** vector 中的所有元素：

```
myVector.clear(); // 清空 vector
```

### 函数特性

#### 默认参数值

也可以使用默认参数值，方法是使用等号(`=`).

如果我们不带参数调用函数，它将使用默认值("Norway"):

比如：

```
 void myFunction(string country = "Norway") {
 
}
```

####  通过引用传递参数

在需要更改参数值时，在**形参变量名前加&**

### OOP面向对象编程

过程编程是关于编写对数据执行操作的过程或函数，而面向对象编程是创建同时包含数据和函数的对象。

优点：

- OOP 更快更容易执行
- OOP 为程序提供了清晰的结构
- OOP 有助于保持C++代码"不重复自己"，并使代码更易于维护、修改和调试。
- OOP 使得用更少的代码和更短的开发时间创建完全可重用的应用程序成为可能

#### 类和对象

类是对象的模板，而对象是类的实例。

创建单个对象时，它们继承类中的所有变量和函数。

### 类

**创建**一个名为"`MyClass`"的类:

```
class MyClass {      // 类
public:         // 访问修饰符
  int myNum;    // 属性（int 变量）  
  string myString; // 属性（string 变量）
};
```

#### 类成员函数

- 类内部定义

  在类定义中定义的成员函数把函数声明为**内联**的，即便没有使用 inline 标识符。

- ```
  class MyClass {    // 类
     public:         // 访问修饰符
    void myMethod() { // 类内部定义的方法/函数  
     cout << "Hello World!";
      }
  };
  ```

  

- 类外部定义

  也可以在类的外部使用**范围解析运算符 ::** 定义该函数

- ```
  class MyClass {    // 类
    public:         // 访问修饰符
    void myMethod();  // 方法/函数声明
  };
  
  // 类外的方法/函数定义
  void MyClass::myMethod() {
    cout << "Hello World!";
  }
  
  
  ```

  

#### 构造函数

在创建类的对象时自动调用。

不会返回任何类型，也不会返回 void。

要创建构造函数，请使用与类相同的名称，后跟括号`()`:

```c++
class MyClass {     // 类
  public:           // 访问修饰符
    MyClass() {     // 构造函数
      cout << "Hello World!";
    }
};

int main() {
  MyClass myObj;    // 创建一个 MyClass 的对象（这将调用构造函数）
  return 0;
}


```

构造函数还可以**获取参数**（就像常规函数一样），这对于**设置属性的初始值**非常有用。

```c++
class Car {        // 类
  public:          // 访问修饰符
    string brand;  // 属性
    string model;  // 属性
    int year;      // 属性
    Car(string x, string y, int z) { // 带参数的构造函数
      brand = x;
      model = y;
      year = z;
    }
};

int main() {
  // 创建 Car 对象并使用不同的值调用构造函数
  Car carObj1("BMW", "X5", 1999);
  Car carObj2("Ford", "Mustang", 1969);

  // 打印值
  cout << carObj1.brand << " " << carObj1.model << " " << carObj1.year << "\n";
  cout << carObj2.brand << " " << carObj2.model << " " << carObj2.year << "\n";
  return 0;
}
```

##### 使用初始化列表来初始化字段（比较新的形式）

```
class MyClass {
private:
    int a;
    int b;
    const int c;
    int& ref;
public:
    MyClass(int x, int y, int z, int& r) : a(x), b(y), c(z), ref(r) {
        // 构造函数体
    }
};
```

在这个示例中，`a`、`b`、`c`和`ref`分别通过成员初始化列表进行初始化。

原理和优势:

成员初始化列表在构造函数体执行之前，直接对成员变量进行初始化。相比于在构造函数体内进行赋值操作，成员初始化列表具有以下几个优势：

- ‌**效率高**‌：直接在对象构造之初对成员变量进行初始化，避免了先调用默认构造函数再进行赋值的过程，提高了初始化的效率。
- ‌**避免不必要的初始化**‌：通过成员初始化列表，可以精确地对成员变量进行初始化，避免了不必要的默认初始化，特别是对于非内置类型的成员变量。
- ‌**支持特殊类型成员**‌：成员初始化列表是**初始化常量成员和引用成员**的唯一方式，同时也支持非静态常量成员的初始化。

使用场景:

成员初始化列表尤其适用于以下情况：

- ‌**初始化常量成员和引用成员**‌：常量成员和引用成员必须在对象构造时进行初始化，而成员初始化列表是唯一支持这种初始化的方式。
- ‌**避免不必要的默认初始化**‌：如果成员变量的默认构造函数执行开销较大，或者需要传递参数进行初始化，使用成员初始化列表**可以避免不必要的默认初始化**。
- ‌**初始化非静态常量成员**‌：非静态常量成员在对象构造之前需要确定其值，成员初始化列表可以满足这一需求。

#### 析构函数

在每次删除所创建的对象时执行。

在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

适用于含有指针对象的类

```C++
class Line
{
   public:
      void setLength( double len );
      double getLength( void );
      Line();   // 这是构造函数声明
      ~Line();  // 这是析构函数声明
 
   private:
      double length;
};
```

#### 拷贝构造函数

拷贝构造函数是C++中的一种特殊的构造函数，其作用是在创建一个新对象时，将一个已存在的对象的值复制给这个新对象。它通常在以下情况下被调用：

1. 当一个对象以值传递的方式被传递给函数时。
2. 当一个对象从函数返回时。
3. 当一个对象需要被初始化为另一个已经存在的对象时。

```c++
class ClassName {
public:
    // 拷贝构造函数
    ClassName(const ClassName& other) {
        // 代码来初始化当前对象的成员变量，通常通过复制other对象的成员变量
    }
    // 其他成员函数...
};
```

在这个例子中，`ClassName` 是类的名称，`other` 是一个常量引用，指向要复制的对象。使用常量引用是为了防止拷贝构造函数在复制过程中修改原始对象。

如果在类中没有定义拷贝构造函数，**编译器会自行定义一个**。**拷贝构造函数的默认行为通常是逐成员地复制对象的每个成员变量**。但是，如果**类中有指针成员或者需要深拷贝的场景**，通常需要自定义拷贝构造函数来确保正确地复制资源。

例如，如果类中有一个指向动态分配内存的指针，那么拷贝构造函数需要**确保为新对象分配新的内存，并复制数据，而不是仅仅复制指针，这样可以避免多个对象共享同一块内存，导致潜在的内存泄漏问题。**

```C++
class MyClass {
public:
    int* data;

    MyClass(int value) {
        data = new int(value);
    }

    // 自定义拷贝构造函数
    MyClass(const MyClass& other) {
        data = new int(*(other.data)); // 深拷贝
    }

    // 析构函数，用于释放内存
    ~MyClass() {
        delete data;
    }
};
```

如果只提供拷贝构造函数，编译器就不再生成默认构造函数，会而导致类对象就不可以直接创建，所以还需要提供一个（不带参数的）默认构造函数

#### 比较新的形式

```
//拷贝构造函数，新开辟一个堆变量，用m_age管理，数值设置为from的m_age管理的对变量的数值
Student::Student(const Student& from):m_age(new int(*from.m_age))
{
}
```



#### 访问修饰符

访问修饰符定义如何访问类的成员

基本格式：

```C++
class Base {
 
   public:
 
  // 公有成员
 
   protected:
 
  // 受保护成员
 
   private:
 
  // 私有成员
 
};
```

在C++中，有三个访问修饰符:

- `public` - 成员可以**从类外**访问
- `private` - 不能从类外部访问（或查看）成员，只有**该类和友元函数**可以访问私有成员。
- `protected` - 不能从类外部访问（或查看）成员，只有**该类，派生类（即子类）和友元函数**可以访问成员。
-  默认情况下，如果不指定访问修饰符，则类的所有成员都是私有的

实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数

```C++
class Box
{
   public:
      double length;
      void setWidth( double wid );
      double getWidth( void );
 
   private:
      double width;
};
```



#### 封装

封装的意义是确保对用户隐藏敏感数据。为此，必须将类变量/属性声明为 `private` （不能从类外部访问）。如果希望其他人读取或修改私有成员的值，可以提供公共**get**和**set**方法。

```c++
class Employee {
  private:
    // 私有属性
    int salary;

  public:
    // Setter
    void setSalary(int s) {
      salary = s;
    }
    // Getter
    int getSalary() {
      return salary;
    }
};
```

#### 继承

在 C++ 中，可以从一个类继承到另一个类的属性和方法。我们将继承概念分为两类:

- 派生类（子类）**derived class** (child) - 从另一个类继承的类
- 基类（父级）**base class** (parent) - 从中继承的类

要从类继承，请使用`:`符号。

```c++
// 基类
class Vehicle {
  public:
    string brand = "Ford";
    void honk() {
      cout << "Tuut, tuut! \n" ;
    }
};

// 派生类
class Car: public Vehicle {
  public:
    string model = "Mustang";
};

```

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。

我们几乎不使用 **protected** 或  **private** 继承，通常使用 **public** 继承。

- 1.**public 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
- 2.**protected 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
- 3.**private 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

##### 函数的继承

构造函数：

1. 继承基类
2. 在子类中声明构造函数时显式地继承基类构造函数，重新定义的部分在基类构造函数内容之后执行
3. 继承语法如下：`Derived(int p, int s, string c) :Base(p, s,c) {`

```C++
class Car1{
public:
	int price_$;
	int size_m;
	string color;
	Car1(int p, int s, string c);
};

class Car2 {
public:
	string where;
	int when;
};

class Car :public Car1, public Car2 {
public:
	Car(int p, int s, string c) :Car1(p, s,c) {
		cout << "hello world2";
}
};

Car1::Car1(int p, int s, string c){
	price_$ = p;
	size_m = s;
	color = c;
	cout << "hello world1";

};
```

普通函数：

1. **继承基类：**`class Derived : public Base`
2. **使用作用域解析运算符**：在 `Derived` 类中，你可以通过 `Base::functionName()` 的方式来显式调用 `Base` 类的成员函数。
3. **使用using声明**：在 `Derived` 类中，你可以使用 `using Base::functionName;` 来引入 `Base` 类的成员函数，使其在 `Derived` 类的范围内可见。
4. **重新定义成员函数**：

```C++
#include <iostream>
#include <string>

class Base {
public:
    void display() const {
        std::cout << "Display from Base" << std::endl;
    }
};

class Derived : public Base {
public:
    // 使用using声明来引入Base类的display函数
    using Base::display;

    void display() const {
        std::cout << "Display from Derived" << std::endl;
        // 可以显式调用Base类的display函数
        Base::display();
    }
};

int main() {
    Derived d;
    d.display(); // 调用Derived类的display函数，它覆盖了Base类的display函数
    ((Base&)d).display(); // 显式地将Derived对象转换为Base引用，调用Base类的display函数
    return 0;
}


```

在这个示例中，Derived 类通过 using 声明引入了 Base 类的 display 函数，并且也重新定义了自己的 display 函数。在 Derived 类的 display 函数中，它显式地调用了 Base 类的 display 函数。此外，我们也可以通过显式类型转换来调用 Base 类的 display 函数。

请注意，如果 Derived 类重新定义了 Base 类的成员函数，并且没有使用 virtual 关键字声明该函数为虚函数，那么这种重新定义的行为不被称为覆盖，而是隐藏。在这种情况下，除非显式地通过 Base::functionName() 调用，否则 Base 类的成员函数将不会被 Derived 类的对象所使用。

#### 多级继承

一个类也可以从一个已经派生的类派生。

#### 多重继承

一个类也可以从多个基类派生，使用**逗号分隔列表:**

```C++
class MyChildClass: public MyClass, public MyOtherClass {
};
```

#### 多态

多态是为解决复杂为题而产生的解决方案。

多态是让**基类提供接口**（成员函数），**派生类分别各自重新实现**（override），运行时以基类接口访问各个对象，但执行的是各个派生类各自实现的版本的这样一种机制。

多态性意味着许多形式，当我们**有许多类通过继承相互关联时，多态性就会出现。**

C++ 多态意味着调用成员函数时，会**根据调用函数的对象的类型来执行不同的函数**。

```C++
#include <iostream> 
using namespace std;
 
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }
};
class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }
};
// 程序的主函数
int main( )
{
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);
 
   // 存储矩形的地址
   shape = &rec;
   // 调用矩形的求面积函数 area
   shape->area();
 
   // 存储三角形的地址
   shape = &tri;
   // 调用三角形的求面积函数 area
   shape->area();
   
   return 0;
}
```

导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的**静态多态**，或**静态链接** - 函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为 area() 函数在程序编译期间就已经设置好了。

但现在，让我们对程序稍作修改，**在 Shape 类中，area() 的声明前放置关键字 virtual。**

此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。

正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是**多态**的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，**函数的参数甚至可以是相同的**。

#### 基类指针容器存储派生类地址，从而使能统一调用派生类

```
#include <iostream>
#include <vector>
#include <string>
using namespace std;
//IShape只提供计算面积的行为
struct IShape
{
    //多态的条件1：基类提供虚函数
    // = 0 表示纯虚函数，用于禁止直接创建IShape的对象（一般都建议这么做）
    virtual void printArea(void) const = 0;
    //基类的析构函数一般都应该是虚函数（以使用多态调用派生类的析构函数）
    virtual ~IShape(void) {}
};
//圆形继承了IShape
struct Circle : public IShape
{
    //多态的条件2：派生类实现基类的函数
    //圆形计算面积的方式
    void printArea(void) const override
    {
        cout << "I',m a Circle. r=" << r << ", area="
            << (3.1415926 * r * r) << endl;
    }
    float r;
};
//正方形形继承了IShape
struct Square : public IShape
{
    //多态的条件2：派生类实现基类的函数
    //正方形计算面积的方式
    void printArea(void) const override
    {
        cout << "I',m a Square. side=" << side << ", area="
            << (side * side) << endl;
    }
    float side;
};
 
int main()
{
    Circle circle;//创建一个圆形对象
    circle.r = 2;//圆形的半径是2
 
    Circle circle2;//创建一个圆形对象
    circle2.r = 2.5;//圆形的半径是2.5
 
    Square square;//创建一个正方形对象
    square.side = 3;//正方形的边长是3.5
 
    Square square2;//创建一个正方形对象
    square2.side = 4;//正方形的边长是4.2
 
    //创建一个数组对象，把上面所有形状对象都放进去
    vector<IShape*> arrShape{ &circle, &circle2, &square , &square2 };
    //用范围循环遍历所有形状对象
    for (int i = 0; i < arrShape.size(); ++i)
    {
        arrShape[i]->printArea();//这里会执行各个派生类对象的成员函数：多态因此而来
    }
    return 0;
}
```



#### 虚函数



在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

#### 纯虚函数

您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

在类中声定义时：

```C++
virtual int area() = 0;
```

= 0 告诉编译器，函数没有主体，上面的虚函数是**纯虚函数**。

#### 抽象类

如果**类中至少有一个函数被声明为纯虚函数**，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的。

设计抽象类（通常称为 **ABC**）的目的，是为了**给其他类提供一个可以继承的适当的基类**。抽象类**不能被用于实例化对象**，它只能作为**接口**使用。**如果试图实例化一个抽象类的对象，会导致编译错误。**

如果一个 ABC 的子类需要被实例化，则**必须实现每个纯虚函数**，这也意味着 C++ 支持使用 ABC 声明接口。**如果没有在派生类中重写**纯虚函数，就尝试实例化该类的对象，**会导致编译错误**。

可用于实例化对象的类被称为**具体类**。

```c++
// 基类
class Shape 
{
public:
   // 提供接口框架的纯虚函数
   virtual int getArea() = 0;
   void setWidth(int w)
   {
      width = w;
   }
   void setHeight(int h)
   {
      height = h;
   }
protected:
   int width;
   int height;
};
 
// 派生类
class Rectangle: public Shape
{
public:
   int getArea()
   { 
      return (width * height); 
   }
};
class Triangle: public Shape
{
public:
   int getArea()
   { 
      return (width * height)/2; 
   }
};
```



> 定义一个函数为虚函数，不代表函数为不被实现的函数。
>
> 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
>
> 定义一个函数为纯虚函数，才代表函数没有被实现。
>
> 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

#### 友元函数

**定义在类外部**，但**有权访问类的所有私有（private）成员和保护（protected）成员**。尽管友元函数的原型有在类的定义中出现过，但是友元函数**并不是成员函数**。

友元可以是一个函数，该函数被称为**友元函数**；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**

声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明：

```c++
friend class ClassTwo;
```

```c++
class Box
{
   double width;
public:
   friend void printWidth( Box box );
   void setWidth( double wid );
};
 
// 成员函数定义
void Box::setWidth( double wid )
{
    width = wid;
}
 
// 请注意：printWidth() 不是任何类的成员函数
void printWidth( Box box )
{
   /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */
   cout << "Width of box : " << box.width <<endl;
}
 
```

**友元函数的使用**

因为友元函数没有this指针，则参数要有三种情况： 

要访问**非static成员**时，**需要对象做参数**；

要访问**static成员或全局变量**时，则**不需要**对象做参数；

如果**做参数的对象是全局对象**，则**不需要**对象做参数.

#### 内联函数

C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会**把该函数的代码副本放置在每个调用该函数的地方**。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在**函数名前面放置关键字 inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 **inline** 说明符。

例如：

```C++
inline int Max(int x, int y)
{
   return (x > y)? x : y;
}
```

#### 指向类的指针

一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 **->**

#### this 指针

this 表示当前对象的地址。根据地址变量的特性，对地址变量解引用就可以得到对象的引用。

- **this**是一个隐藏的常量指针，指向当前对象的实例，每一个对象都能通过 **this** 指针来访问自己的地址。
- 可以在类的成员函数中使用，它可以用来指向调用对象。
- 当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 **this** 指针。
- 友元函数没有 **this** 指针，因为友元不是类的成员，只有成员函数才有 **this** 指针。

例如：

```c++
class MyClass {
private:
    int value;
 
public:
    void setValue(int value) {
        this->value = value;
    }
 
    void printValue() {
        std::cout << "Value: " << this->value << std::endl;
    }
};
 
```

### 智能指针shared_ptr

```cpp
#include<memory>
```

```cpp
shared_ptr<int> ptr = make_shared<int>();//手动申请一个堆上的无名int变量，交给智能指针对象ptr来管理
//类似于
//int* ptr = new int;
//但是自动new和delete
```

在一些类似生产者消费者的业务模式中，shared_ptr往往是比较适用的。

这种场景下内存没有办法事先开辟好，只能随着业务的需要临时创建，创建的对象又要经过多个模块加工处理。

这种情况显然适合使用动态内存，动态内存在多个模块之间流转，谁去释放呢？干脆交给智能指针去释放。

```cpp
#include <iostream>
#include <memory>
using namespace std;

struct Buffer
{
    Buffer() { cout << "Buffer()" << endl; }
    ~Buffer() { cout << "~Buffer()" << endl; }
    int i = 0;
};

shared_ptr<Buffer> CreateBuffer(void)
{
    return make_shared<Buffer>();
}

void Module1(shared_ptr<Buffer> buffer)
{
    buffer->i++;
    cout << "Module1 use buffer i = "<<buffer->i << endl;
}

void Module2(shared_ptr<Buffer> buffer)
{
    buffer->i++;
    cout << "Module2 use buffer i = " << buffer->i << endl;
}

void Module3(shared_ptr<Buffer> buffer)
{
    buffer->i++;
    cout << "Module3 use buffer i = " << buffer->i << endl;
}

int main()
{
    auto buffer = CreateBuffer();
    Module1(buffer);
    Module2(buffer);
    Module3(buffer);

    return 0;
}
```

#### 类的静态成员

类的静态成员 static member 变量全局只有一份副本，不会随着类对象的创建而产生新的副本。

在类的成员变量前面增加**static**关键字，表示这个成员变量是类的静态成员变量。

静态成员**在类的所有对象中是共享的**。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们**不能把静态成员的初始化放置在类的定义中**，必须在外部初始化，但是可以**在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化**

##### 初始化

在C++中，静态成员变量的初始化应该在**类的外部**进行，并且应该**在任何函数（包括`main`函数）调用之前完成**。这是因为静态成员变量属于全局或静态存储期，它们在程序启动时就被初始化，而不是在`main`函数执行时。

例如：

```
#include <iostream>
using namespace std;
struct MyStruct {
    // 下面的这条初始化语句等价于下面的两条语句：
    //（1）ider= ider+ 1; 
    //（2）id = ider;
    MyStruct() :id(++ider)
   {
    }

    int id;
    static int ider;//将
};

int MyStruct::ider = 0;
//(0) main函数开始执行之前
int main()
{
    //(1)创建对象my1，执行完下面这条语句之后，MyStruct::ider== 1, my1.id == 1 
    MyStruct my1;//(1)
    //(2)创建对象my2，执行完下面这条语句之后，MyStruct::ider== 2, my1.id == 2 
    MyStruct my2;//(2)
    //(3)创建对象my3，执行完下面这条语句之后，MyStruct::ider== 3, my1.id == 3 
    MyStruct my3;//(3)

    //my1.increaser和MyStruct::increaser是同一个变量
    //，只不过一个是通过对象访问，一个是通过类名访问
    cout << my1.id << " " << MyStruct::ider<< endl;
    cout << my2.id << " " << MyStruct::ider<< endl;
    cout << my3.id << " " << MyStruct::ider<< endl;

    return 0;
}

```

### 赋值运算符重载+非平凡类

```
class Student{
  Student& operator=(const Student& stuFrom);
private:
  int* m_age;//指针成员：管理动态内存
};
Student& Student::operator=(const Student& stuFrom){
  if(this == &stuFrom)//自己赋值给自己，直接返回自己
  {
     return *this;
  }
  *m_age = *stuFrom.m_age;//深拷贝，将存储的数据拷贝，而不是直接地址拷贝
  return *this;
}

```



### 静态成员函数

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符 **::** 就可以访问。

静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。

静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。

> **静态成员函数与普通成员函数的区别：**
>
> - 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
> - 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。

### 重载运算符和重载函数

C++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

当您调用一个**重载函数**或**重载运算符**时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为**重载决策**。

#### 函数重载

在同一个作用域内，可以声明**几个功能类似**的**同名**函数，但是这些同名函数的**形式参数（指参数的个数、类型或者顺序）必须不同**。您**不能仅通过返回类型的不同**来重载函数。

#### 运算符重载

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

```
Box operator+(const Box&);//类的成员函数

//在类内定义
Box operator+(const Box& b)
{
   Box box;
   box.length = this->length + b.length;
   box.breadth = this->breadth + b.breadth;
   box.height = this->height + b.height;
   return box;
}
```

```
Box operator+(const Box&, const Box&);//非类的成员函数

//在类外定义
Box operator+(const Box&b1, const Box&b2)
{
   Box box;
   box.length = b1length + b2.length;
   box.breadth = b1.breadth + b2.breadth;
   box.height = b1.height + b2.height;
   return box;
}
```

可重载的运算符列表：

| 双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)                        |
| -------------- | ------------------------------------------------------------ |
| 关系运算符     | ==(等于)，!= (不等于)，< (小于)，> (大于)，<=(小于等于)，>=(大于等于) |
| 逻辑运算符     | \|\|(逻辑或)，&&(逻辑与)，!(逻辑非)                          |
| 单目运算符     | + (正)，-(负)，*(指针)，&(取地址)                            |
| 自增自减运算符 | ++(自增)，--(自减)                                           |
| 位运算符       | \| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移) |
| 赋值运算符     | =, +=, -=, *=, /= , % = , &=, \|=, ^=, <<=, >>=              |
| 空间申请与释放 | new, delete, new[ ] , delete[]                               |
| 其他运算符     | ()(函数调用)，->(成员访问)，,(逗号)，[](下标)                |

不可重载的运算符列表：

- `.`：成员访问运算符
- `.*`, `->*`：成员指针访问运算符
- `::`：域运算符
- `sizeof`：长度运算符
- `?:`：条件运算符
- \`#`： 预处理符号

### 文件1

```
#include <iostream>
#include <fstream> 
```

`fstream` 库中包含三个**类**，用于创建、写入或读取文件:

| 类         | 描述                                          |
| ---------- | --------------------------------------------- |
| `ofstream` | 创建和写入文件                                |
| `ifstream` | 从文件读取                                    |
| `fstream`  | ofstream和ifstream的组合:创建、读取和写入文件 |

#### 创建并写入文件

```C++
#include <iostream>
#include <fstream>
using namespace std;

int main() {    
// 创建并打开一个文本文件    
ofstream MyFile("filename.txt");
   
// 写入文件    
MyFile << "Files can be tricky, but it is fun enough!";
   
// 关闭文件    
MyFile.close();
} 
```

#### 读取文件

```C++
// 创建一个文本字符串，用于输出文本文件
string myText;

// 从文本文件中读取
ifstream MyReadFile("filename.txt");

// 使用 while 循环和 getline() 函数逐行读取文件
while (getline (MyReadFile, myText)) {
  // 从文件中输出文本
  cout << myText;
}

// 关闭文件
MyReadFile.close(); 
```

```c++
//打开文件out.txt
ifstream fin("data.txt");
if (!fin.is_open())
{
	cout << "文件data.txt不存在!" << endl;
	return 0;
}
```

### 文件2

**ofstream** 和 **fstream** 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 **ifstream** 对象。

#### 打开文件

**open()**函数，是fstream、ifstream 和 ofstream 对象的一个成员。：

```C++
void open(const char *filename, ios::openmode mode);
```

在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。

| 模式标志   | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| ios::app   | 追加模式。所有写入都追加到文件末尾。                         |
| ios::ate   | 文件打开后定位到文件末尾。                                   |
| ios::in    | 打开文件用于读取。                                           |
| ios::out   | 打开文件用于写入。                                           |
| ios::trunc | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 |

可以把以上两种或两种以上的模式结合使用，例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法：

```C++
ofstream outfile;
outfile.open("file.dat", ios::out | ios::trunc );
```

类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：

```C++
ifstream  afile;
afile.open("file.dat", ios::out | ios::in );
```

#### 关闭文件

当 C++ 程序终止时，它会**自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件**。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。

下面是 **close() 函数**的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。

```c++
void close();
```

#### 写入文件和读取文件

将ofstream类对象看作cout使用，ifstream类对象看作cin使用，fstream类对象看作cin和cout使用。

#### 文件位置指针

**istream** 和 **ostream** 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 **seekg**（"seek get"）和关于 ostream 的 **seekp**（"seek put"）。

seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 **ios::beg**（默认的，从流的开头开始定位），也可以是 **ios::cur**（从流的当前位置开始定位），也可以是 **ios::end**（从流的末尾开始定位）。

文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。

```c++
// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）
fileObject.seekg( n );
 
// 把文件的读指针从 fileObject 当前位置向后移 n 个字节
fileObject.seekg( n, ios::cur );
 
// 把文件的读指针从 fileObject 末尾往回移 n 个字节
fileObject.seekg( n, ios::end );
 
// 定位到 fileObject 的末尾
fileObject.seekg( 0, ios::end );
```



### 异常处理

在执行 C++ 代码时，可能会发生不同的错误:程序员编写的编码错误、错误输入引起的错误或其他不可预见的事情。

当发生错误时，C++ 通常会停止并生成错误消息。这个术语的技术术语是:C++ 抛出**exception**异常（抛出错误）。

三个关键字: `try`, `throw` and `catch`:

1. `try` 语句允许您定义要在执行时测试错误的代码块。**try 块中放置可能抛出异常的代码**，try 块中的代码被称为保护代码。
2. `throw` 关键字**在检测到问题时抛出异常**，这使我们可以创建自定义错误。
3. `catch` 语句允许您**在try块中发生错误时定义要执行的代码块**。

`try` 和 `catch` 关键字成对出现:

```c++
try {
 int age = 15;
 if (age > 18) {
      cout << "Access granted - you are old enough.";
 } else {
      throw (age);
 }
}
catch (int myNum) {
 cout << "Access denied - You must be at least 18 years     old.\n";
 cout << "Age is: " << myNum; 
} 
```

我们使用`try`块来测试一些代码:如果`age`变量小于`18`，我们将抛出`throw`一个异常，并在`catch`块中处理它。

如果没有发生错误（例如，如果`age`是`20`而不是`15`，意味着它将大于18），则跳过`catch`块:

还可以使用`throw`关键字输出异常参考编号，例如错误数字码/代码:

```c++
try {
  int age = 15;
  if (age > 18) {
    cout << "Access granted - you are old enough.";
  } else {
    throw 505;
  }
}
catch (int myNum) {
  cout << "Access denied - You must be at least 18 years old.\n";
  cout << "Error number: " << myNum;
} 
```

如果 **try** 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 **catch** 语句，用于捕获不同类型的异常。

**处理任何类型的异常** ：

如果不知道`try`块中使用的`throw`类型， 可以在`catch`块中使用三点语法(`...`)，它将处理任何类型的异常:

```C++
try {
	int age = 15;
	if (age > 18) {
    	cout << "Access granted - you are old enough.";
	} else {
    	throw 505;
	}
}
catch (...) {
	cout << "Access denied - You must be at least 18 years     old.\n";
} 
```

完整的例子，用于检测除以零的错误：

```C++
#include <iostream>
using namespace std;
 
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
 
int main ()
{
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
     z = division(x, y);
     cout << z << endl;
   }catch (const char* msg) {
     cerr << msg << endl;
   }
 
   return 0;
}
```

#### C++ 标准的异常

![C++ 异常的层次结构](https://www.runoob.com/wp-content/uploads/2015/05/exceptions_in_cpp.png)

下表是对上面层次结构中出现的每个异常的说明：

| 异常                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| **std::exception**     | 该异常是所有标准 C++ 异常的父类。                            |
| std::bad_alloc         | 该异常可以通过 **new** 抛出。                                |
| std::bad_cast          | 该异常可以通过 **dynamic_cast** 抛出。                       |
| std::bad_typeid        | 该异常可以通过 **typeid** 抛出。                             |
| std::bad_exception     | 这在处理 C++ 程序中无法预期的异常时非常有用。                |
| **std::logic_error**   | 理论上可以通过读取代码来检测到的异常。                       |
| std::domain_error      | 当使用了一个无效的数学域时，会抛出该异常。                   |
| std::invalid_argument  | 当使用了无效的参数时，会抛出该异常。                         |
| std::length_error      | 当创建了太长的 std::string 时，会抛出该异常。                |
| std::out_of_range      | 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。 |
| **std::runtime_error** | 理论上不可以通过读取代码来检测到的异常。                     |
| std::overflow_error    | 当发生数学上溢时，会抛出该异常。                             |
| std::range_error       | 当尝试存储超出范围的值时，会抛出该异常。                     |
| std::underflow_error   | 当发生数学下溢时，会抛出该异常。                             |

#### 定义新的异常

您可以通过继承和重载 **exception** 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：

```C++
#include <iostream>
#include <exception>
using namespace std;
 
struct MyException : public exception
{
  const char * what () const throw ()
  {
    return "C++ Exception";
  }
};
 
int main()
{
  try
  {
    throw MyException();
  }
  catch(MyException& e)
  {
    std::cout << "MyException caught" << std::endl;
    std::cout << e.what() << std::endl;
  }
  catch(std::exception& e)
  {
    //其他的错误
  }
}
```

这将产生以下结果：

```
MyException caught
C++ Exception
```

在这里，**what()** 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。

### 动态内存

C++ 程序中的内存分为两个部分:

- **栈:**在函数内部声明的所有变量都将占用栈内存。
- **堆:**这是程序中未使用的内存，在程序运行时可用于动态分配内存。

#### new和delete

```c++
#include <iostream>
using namespace std;
 
int main ()
{
   double* pvalue  = NULL; // 初始化为 null 的指针
   pvalue  = new double;   // 为变量请求内存
 
   *pvalue = 29494.99;     // 在分配的地址存储值
   cout << "Value of pvalue : " << *pvalue << endl;
 
   delete pvalue;         // 释放内存
 
   return 0;
}
```

如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：

```c++
double* pvalue  = NULL;
if( !(pvalue  = new double ))
{
   cout << "Error: out of memory." <<endl;
   exit(1);
 
}
```

**malloc()** 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。

#### 数组的动态内存分配

如下所示：

```C++
char* pvalue  = NULL;   // 初始化为 null 的指针
pvalue  = new char[20]; // 为变量请求内存
```

要删除我们刚才创建的数组，语句如下：

```c++
delete [] pvalue;        // 删除 pvalue 所指向的数组
```

### 命名空间

您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。

因此，引入了**命名空间**这个概念，专门用于解决上面的问题，它可**作为附加信息来区分不同库中相同名称的函数、类、变量**等。使用了命名空间即定义了上下文。本质上，**命名空间就是定义了一个范围**。

#### 定义命名空间

命名空间的定义使用关键字 **namespace**，后跟命名空间的名称，如下所示：

```c++
namespace namespace_name {   
// 代码声明
}
```

为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：

```c++
name::code;  // code 可以
```

例如：

```C++
#include <iostream>
using namespace std;
 
// 第一个命名空间
namespace first_space{
   void func(){
      cout << "Inside first_space" << endl;
   }
}
// 第二个命名空间
namespace second_space{
   void func(){
      cout << "Inside second_space" << endl;
   }
}
int main ()
{
 
   // 调用第一个命名空间中的函数
   first_space::func();
   
   // 调用第二个命名空间中的函数
   second_space::func(); 
 
   return 0;
}
```

#### using 指令

您可以使用 **`using namespace`** 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。**这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。**



using 指令也可以用来**指定命名空间中的特定项目**。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：

```C++
using std::cout;
```

随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 **std** 命名空间中的其他项目仍然需要加上命名空间名称作为前缀

#### 不连续的命名空间

命名空间的定义可以分散在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以**分散在多个文件中**。

#### 嵌套的命名空间

命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间。

您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员：

```C++
// 访问 namespace_name2 中的成员 
using namespace namespace_name1::namespace_name2; 
```

在上面的语句中，**如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的**，且如果两个命名空间定义了同名函数，优先使用namespace_name2的。

### 模板

模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。

模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。

每个容器都有一个单一的定义，比如 **向量**，我们可以定义许多不同类型的向量，比如 **vector <int>**  或 **vector <string>**。

#### 函数模板

```C++
template <typename T>
inline T const& Max (T const& a, T const& b) 
{ 
    return a < b ? b:a; 
} 
```

1. **模板声明** (`template <typename T>`)：这告诉编译器`Max`是一个模板函数，它接受一个类型参数`T`。`typename`关键字用于指定`T`是一个类型。
2. **内联函数修饰符** (`inline`)：`inline`关键字是一个请求，它建议编译器在编译时将函数的代码直接插入到每个调用点，以减少函数调用的开销。这通常用于小型函数，以提高程序的运行效率。
3. **返回类型** (`T const&`)：函数的返回类型是`T const&`，这意味着函数返回一个对常量值的引用。使用引用（`&`）可以避免返回值时的拷贝，提高效率。`const`修饰符确保返回的引用不会修改原始数据。
4. **函数名** (`Max`)：这是函数的名称，按照惯例，函数名通常描述了函数的功能。
5. **函数参数列表** (`(T const& a, T const& b)`)：函数接受两个参数，`a`和`b`，它们的类型都是`T const&`。这意味着你可以传递任意类型的常量引用给这个函数。

#### 类模板

泛型类声明的一般形式如下所示：

```C++
template <class type> class class-name {
.
.
.
}
```

在这里，**type** 是占位符类型名称，可以在类被实例化的时候进行指定。您可以**使用一个逗号分隔的列表来定义多个泛型数据类型**。

下面的实例定义了类 Stack<>，并实现了泛型方法来对元素进行入栈出栈操作：

```C++
#include <iostream>
#include <vector>
#include <cstdlib>
#include <string>
#include <stdexcept>
 
using namespace std;
 
template <class T>
class Stack { 
  private: 
    vector<T> elems;     // 元素 
 
  public: 
    void push(T const&);  // 入栈
    void pop();               // 出栈
    T top() const;            // 返回栈顶元素
    bool empty() const{       // 如果为空则返回真。
        return elems.empty(); 
    } 
}; 
 
template <class T>
void Stack<T>::push (T const& elem) 
{ 
    // 追加传入元素的副本
    elems.push_back(elem);    
} 
 
template <class T>
void Stack<T>::pop () 
{ 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::pop(): empty stack"); 
    }
    // 删除最后一个元素
    elems.pop_back();         
} 
 
template <class T>
T Stack<T>::top () const 
{ 
    if (elems.empty()) { 
        throw out_of_range("Stack<>::top(): empty stack"); 
    }
    // 返回最后一个元素的副本 
    return elems.back();      
} 
 
int main() 
{ 
    try { 
        Stack<int>         intStack;  // int 类型的栈 
        Stack<string> stringStack;    // string 类型的栈 
 
        // 操作 int 类型的栈 
        intStack.push(7); 
        cout << intStack.top() <<endl; 
 
        // 操作 string 类型的栈 
        stringStack.push("hello"); 
        cout << stringStack.top() << std::endl; 
        stringStack.pop(); 
        stringStack.pop(); 
    } 
    catch (exception const& ex) { 
        cerr << "Exception: " << ex.what() <<endl; 
        return -1;
    } 
}
```

### 预处理器

#### # define 预处理

#### 参数宏：同C

#### 条件编译：同C

#### 预定义宏

C++ 提供了下表所示的一些预定义宏：

| 宏       | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| __LINE__ | 这会在程序编译时包含当前行号。                               |
| __FILE__ | 这会在程序编译时包含当前文件名。                             |
| __DATE__ | 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 |
| __TIME__ | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |

```C++
#include <iostream>
using namespace std;
 
int main ()
{
    cout << "Value of __LINE__ : " << __LINE__ << endl;
    cout << "Value of __FILE__ : " << __FILE__ << endl;
    cout << "Value of __DATE__ : " << __DATE__ << endl;
    cout << "Value of __TIME__ : " << __TIME__ << endl;
 
    return 0;
}
```

```
Value of __LINE__ : 6
Value of __FILE__ : test.cpp
Value of __DATE__ : Feb 28 2011
Value of __TIME__ : 18:52:48
```

### 信号处理

信号是**由操作系统传给进程的中断**，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以**通过按 Ctrl+C 产生中断**。

**有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。**这些信号是定义在 C++ 头文件 <csignal> 中。

| 信号    | 描述                                         |
| ------- | -------------------------------------------- |
| SIGABRT | 程序的异常终止，如调用 **abort**。           |
| SIGFPE  | 错误的算术运算，比如除以零或导致溢出的操作。 |
| SIGILL  | 检测非法指令。                               |
| SIGINT  | 程序终止(interrupt)信号。                    |
| SIGSEGV | 非法访问内存。                               |
| SIGTERM | 发送到程序的终止请求。                       |

#### signal() 函数

C++ 信号处理库提供了 **signal** 函数，用来捕获突发事件。以下是 signal() 函数的语法：

```
void (*signal (int sig, void (*func)(int)))(int); 
```

这个看起来有点费劲，以下语法格式更容易理解：

```
signal(registered signal, signal handler)
```

这个函数接收两个参数：第一个参数是要设置的信号的标识符，第二个参数是指向信号处理函数的指针。函数返回值是一个指向先前信号处理函数的指针。如果先前没有设置信号处理函数，则返回值为 SIG_DFL。如果先前设置的信号处理函数为 SIG_IGN，则返回值为 SIG_IGN。

让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 **signal** 函数来注册信号，并将其与信号处理程序相关联。

```
#include <iostream>
#include <csignal>
#include <unistd.h>
 
using namespace std;
 
void signalHandler( int signum )
{
    cout << "Interrupt signal (" << signum << ") received.\n";
 
    // 清理并关闭
    // 终止程序  
 
   exit(signum);  
 
}
 
int main ()
{
    // 注册信号 SIGINT 和信号处理程序
    signal(SIGINT, signalHandler);  
 
    while(1){
       cout << "Going to sleep...." << endl;
       sleep(1);
    }
 
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Going to sleep....
Going to sleep....
Going to sleep....
```

现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：

```
Going to sleep....
Going to sleep....
Going to sleep....
Interrupt signal (2) received.
```

### 多线程

线程是程序中的轻量级执行单元，允许程序同时执行多个任务。

多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。

一般情况下，两种类型的多任务处理：**基于进程和基于线程**。

- 基于进程的多任务处理是程序的并发执行。
- 基于线程的多任务处理是同一程序的片段的并发执行。

C++ 多线程编程涉及在一个程序中创建和管理多个并发执行的线程。

#### 线程 (Thread)

- 线程是**程序执行中的单一顺序控制流**，**多个线程可以在同一个进程中独立运行**。
- 线程**共享进程的地址空间、文件描述符、堆和全局变量**等资源，但**每个线程有自己的栈、寄存器和程序计数器**。

#### 并发 (Concurrency) 与并行 (Parallelism)

- **并发**：多个任务在时间片段内交替执行，表现出同时进行的效果。
- **并行**：多个任务在多个处理器或处理器核上同时执行。

C++11 及以后的标准提供了多线程支持，核心组件包括：

- **`std::thread`**：用于创建和管理线程。
- **`std::mutex`**：用于线程之间的互斥，防止多个线程同时访问共享资源。
- **`std::lock_guard`** 和 **`std::unique_lock`**：用于管理锁的获取和释放。
- **`std::condition_variable`**：用于线程间的条件变量，协调线程间的等待和通知。
- **`std::future`** 和 **`std::promise`**：用于实现线程间的值传递和任务同步。

#### 未完待续To be continued--->

### 无限循环

```
while(true) // while expression fixed to true
{
DoSomethingRepeatedly;
}
```

```
do
{
DoSomethingRepeatedly;
} while(true); // do…while expression never evaluates to false
```

```
for (;;) // no condition supplied = unending for
{
DoSomethingRepeatedly;
}
```

```
while(expression);//无限循环直到!expression=1
```

break语句退出无限循环

```
while(true) // while condition fixed to true
{
DoSomethingRepeatedly;
if(expression)
break; // exit loop when expression evaluates to true
}
```

